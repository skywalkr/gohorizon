/*
Horizon Server API

Welcome to the Horizon Server API Reference documentation. This API reference provides comprehensive information about status of all Horizon Server components and resources. <br> Choose Latest spec from dropdown to view API reference on latest version available.

API version: 2111
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package gohorizon

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// EntitlementsApiService EntitlementsApi service
type EntitlementsApiService service

type ApiBulkCreateApplicationPoolEntitlementsRequest struct {
	ctx        _context.Context
	ApiService *EntitlementsApiService
	body       *[]EntitlementSpec
}

// Specifications for bulk application entitlements to be created.
func (r ApiBulkCreateApplicationPoolEntitlementsRequest) Body(body []EntitlementSpec) ApiBulkCreateApplicationPoolEntitlementsRequest {
	r.body = &body
	return r
}

func (r ApiBulkCreateApplicationPoolEntitlementsRequest) Execute() ([]BulkEntitlementResponseInfo, *_nethttp.Response, error) {
	return r.ApiService.BulkCreateApplicationPoolEntitlementsExecute(r)
}

/*
BulkCreateApplicationPoolEntitlements Create the bulk entitlements for a set of application pools

The input spec must not contain duplicate Ids.
All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| POOL_ENTITLE | Caller should have permission to this privilege, on the associated access group of application pool.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkCreateApplicationPoolEntitlementsRequest
*/
func (a *EntitlementsApiService) BulkCreateApplicationPoolEntitlements(ctx _context.Context) ApiBulkCreateApplicationPoolEntitlementsRequest {
	return ApiBulkCreateApplicationPoolEntitlementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []BulkEntitlementResponseInfo
func (a *EntitlementsApiService) BulkCreateApplicationPoolEntitlementsExecute(r ApiBulkCreateApplicationPoolEntitlementsRequest) ([]BulkEntitlementResponseInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BulkEntitlementResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsApiService.BulkCreateApplicationPoolEntitlements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/application-pools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkCreateDesktopPoolEntitlementsRequest struct {
	ctx        _context.Context
	ApiService *EntitlementsApiService
	body       *[]EntitlementSpec
}

// Specifications for bulk desktop entitlements to be created.
func (r ApiBulkCreateDesktopPoolEntitlementsRequest) Body(body []EntitlementSpec) ApiBulkCreateDesktopPoolEntitlementsRequest {
	r.body = &body
	return r
}

func (r ApiBulkCreateDesktopPoolEntitlementsRequest) Execute() ([]BulkEntitlementResponseInfo, *_nethttp.Response, error) {
	return r.ApiService.BulkCreateDesktopPoolEntitlementsExecute(r)
}

/*
BulkCreateDesktopPoolEntitlements Create the bulk entitlements for a set of desktop pools

The input spec must not contain duplicate Ids.
All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| POOL_ENTITLE | Caller should have permission to this privilege, on the associated access group of desktop pool.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkCreateDesktopPoolEntitlementsRequest
*/
func (a *EntitlementsApiService) BulkCreateDesktopPoolEntitlements(ctx _context.Context) ApiBulkCreateDesktopPoolEntitlementsRequest {
	return ApiBulkCreateDesktopPoolEntitlementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []BulkEntitlementResponseInfo
func (a *EntitlementsApiService) BulkCreateDesktopPoolEntitlementsExecute(r ApiBulkCreateDesktopPoolEntitlementsRequest) ([]BulkEntitlementResponseInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BulkEntitlementResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsApiService.BulkCreateDesktopPoolEntitlements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/desktop-pools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkCreateGAEEntitlementsRequest struct {
	ctx        _context.Context
	ApiService *EntitlementsApiService
	body       *[]EntitlementSpec
}

// Specifications for bulk GAE Entitlements to be created.
func (r ApiBulkCreateGAEEntitlementsRequest) Body(body []EntitlementSpec) ApiBulkCreateGAEEntitlementsRequest {
	r.body = &body
	return r
}

func (r ApiBulkCreateGAEEntitlementsRequest) Execute() ([]BulkEntitlementResponseInfo, *_nethttp.Response, error) {
	return r.ApiService.BulkCreateGAEEntitlementsExecute(r)
}

/*
BulkCreateGAEEntitlements Create the bulk entitlements for a set of Global Application Entitlements

Note: CPA must be initialized for the pod for invoking this API.<br/>The input spec must not contain duplicate Ids.
All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| FEDERATED_LDAP_MANAGE | Caller should have permission to this privilege, on the associated access group of global application entitlement.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkCreateGAEEntitlementsRequest
*/
func (a *EntitlementsApiService) BulkCreateGAEEntitlements(ctx _context.Context) ApiBulkCreateGAEEntitlementsRequest {
	return ApiBulkCreateGAEEntitlementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []BulkEntitlementResponseInfo
func (a *EntitlementsApiService) BulkCreateGAEEntitlementsExecute(r ApiBulkCreateGAEEntitlementsRequest) ([]BulkEntitlementResponseInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BulkEntitlementResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsApiService.BulkCreateGAEEntitlements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/global-application-entitlements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkCreateGDEEntitlementsRequest struct {
	ctx        _context.Context
	ApiService *EntitlementsApiService
	body       *[]EntitlementSpec
}

// Specifications for bulk GDE Entitlements to be created.
func (r ApiBulkCreateGDEEntitlementsRequest) Body(body []EntitlementSpec) ApiBulkCreateGDEEntitlementsRequest {
	r.body = &body
	return r
}

func (r ApiBulkCreateGDEEntitlementsRequest) Execute() ([]BulkEntitlementResponseInfo, *_nethttp.Response, error) {
	return r.ApiService.BulkCreateGDEEntitlementsExecute(r)
}

/*
BulkCreateGDEEntitlements Create the bulk entitlements for a set of Global Desktop Entitlements

Note: CPA must be initialized for the pod for invoking this API.<br/>The input spec must not contain duplicate Ids.
All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| FEDERATED_LDAP_MANAGE | Caller should have permission to this privilege, on the associated access group of global desktop entitlement.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkCreateGDEEntitlementsRequest
*/
func (a *EntitlementsApiService) BulkCreateGDEEntitlements(ctx _context.Context) ApiBulkCreateGDEEntitlementsRequest {
	return ApiBulkCreateGDEEntitlementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []BulkEntitlementResponseInfo
func (a *EntitlementsApiService) BulkCreateGDEEntitlementsExecute(r ApiBulkCreateGDEEntitlementsRequest) ([]BulkEntitlementResponseInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BulkEntitlementResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsApiService.BulkCreateGDEEntitlements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/global-desktop-entitlements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkDeleteApplicationPoolEntitlementsRequest struct {
	ctx        _context.Context
	ApiService *EntitlementsApiService
	body       *[]EntitlementSpec
}

// Specifications for bulk application entitlements to be deleted.
func (r ApiBulkDeleteApplicationPoolEntitlementsRequest) Body(body []EntitlementSpec) ApiBulkDeleteApplicationPoolEntitlementsRequest {
	r.body = &body
	return r
}

func (r ApiBulkDeleteApplicationPoolEntitlementsRequest) Execute() ([]BulkEntitlementResponseInfo, *_nethttp.Response, error) {
	return r.ApiService.BulkDeleteApplicationPoolEntitlementsExecute(r)
}

/*
BulkDeleteApplicationPoolEntitlements Delete the bulk entitlements for a set of application pools

The input spec must not contain duplicate Ids.
All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| POOL_ENTITLE | Caller should have permission to this privilege, on the associated access group of application pool.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkDeleteApplicationPoolEntitlementsRequest
*/
func (a *EntitlementsApiService) BulkDeleteApplicationPoolEntitlements(ctx _context.Context) ApiBulkDeleteApplicationPoolEntitlementsRequest {
	return ApiBulkDeleteApplicationPoolEntitlementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []BulkEntitlementResponseInfo
func (a *EntitlementsApiService) BulkDeleteApplicationPoolEntitlementsExecute(r ApiBulkDeleteApplicationPoolEntitlementsRequest) ([]BulkEntitlementResponseInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BulkEntitlementResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsApiService.BulkDeleteApplicationPoolEntitlements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/application-pools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkDeleteDesktopPoolEntitlementsRequest struct {
	ctx        _context.Context
	ApiService *EntitlementsApiService
	body       *[]EntitlementSpec
}

// Specifications for bulk desktop entitlements to be deleted.
func (r ApiBulkDeleteDesktopPoolEntitlementsRequest) Body(body []EntitlementSpec) ApiBulkDeleteDesktopPoolEntitlementsRequest {
	r.body = &body
	return r
}

func (r ApiBulkDeleteDesktopPoolEntitlementsRequest) Execute() ([]BulkEntitlementResponseInfo, *_nethttp.Response, error) {
	return r.ApiService.BulkDeleteDesktopPoolEntitlementsExecute(r)
}

/*
BulkDeleteDesktopPoolEntitlements Delete the bulk entitlements for a set of desktop pools

The input spec must not contain duplicate Ids.
All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| POOL_ENTITLE | Caller should have permission to this privilege, on the associated access group of desktop pool.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkDeleteDesktopPoolEntitlementsRequest
*/
func (a *EntitlementsApiService) BulkDeleteDesktopPoolEntitlements(ctx _context.Context) ApiBulkDeleteDesktopPoolEntitlementsRequest {
	return ApiBulkDeleteDesktopPoolEntitlementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []BulkEntitlementResponseInfo
func (a *EntitlementsApiService) BulkDeleteDesktopPoolEntitlementsExecute(r ApiBulkDeleteDesktopPoolEntitlementsRequest) ([]BulkEntitlementResponseInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BulkEntitlementResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsApiService.BulkDeleteDesktopPoolEntitlements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/desktop-pools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkDeleteGAEEntitlementsRequest struct {
	ctx        _context.Context
	ApiService *EntitlementsApiService
	body       *[]EntitlementSpec
}

// Specifications for bulk GAE Entitlements to be Deleted.
func (r ApiBulkDeleteGAEEntitlementsRequest) Body(body []EntitlementSpec) ApiBulkDeleteGAEEntitlementsRequest {
	r.body = &body
	return r
}

func (r ApiBulkDeleteGAEEntitlementsRequest) Execute() ([]BulkEntitlementResponseInfo, *_nethttp.Response, error) {
	return r.ApiService.BulkDeleteGAEEntitlementsExecute(r)
}

/*
BulkDeleteGAEEntitlements Delete the bulk entitlements for a set of Global Application Entitlements

Note: CPA must be initialized for the pod for invoking this API.<br/>The input spec must not contain duplicate Ids.All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| FEDERATED_LDAP_MANAGE | Caller should have permission to this privilege, on the associated access group of global application entitlement.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkDeleteGAEEntitlementsRequest
*/
func (a *EntitlementsApiService) BulkDeleteGAEEntitlements(ctx _context.Context) ApiBulkDeleteGAEEntitlementsRequest {
	return ApiBulkDeleteGAEEntitlementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []BulkEntitlementResponseInfo
func (a *EntitlementsApiService) BulkDeleteGAEEntitlementsExecute(r ApiBulkDeleteGAEEntitlementsRequest) ([]BulkEntitlementResponseInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BulkEntitlementResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsApiService.BulkDeleteGAEEntitlements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/global-application-entitlements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkDeleteGDEEntitlementsRequest struct {
	ctx        _context.Context
	ApiService *EntitlementsApiService
	body       *[]EntitlementSpec
}

// Specifications for bulk GDE Entitlements to be Deleted.
func (r ApiBulkDeleteGDEEntitlementsRequest) Body(body []EntitlementSpec) ApiBulkDeleteGDEEntitlementsRequest {
	r.body = &body
	return r
}

func (r ApiBulkDeleteGDEEntitlementsRequest) Execute() ([]BulkEntitlementResponseInfo, *_nethttp.Response, error) {
	return r.ApiService.BulkDeleteGDEEntitlementsExecute(r)
}

/*
BulkDeleteGDEEntitlements Delete the bulk entitlements for a set of Global Desktop Entitlements

Note: CPA must be initialized for the pod for invoking this API.<br/>The input spec must not contain duplicate Ids.All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| FEDERATED_LDAP_MANAGE | Caller should have permission to this privilege, on the associated access group of global desktop entitlement.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkDeleteGDEEntitlementsRequest
*/
func (a *EntitlementsApiService) BulkDeleteGDEEntitlements(ctx _context.Context) ApiBulkDeleteGDEEntitlementsRequest {
	return ApiBulkDeleteGDEEntitlementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []BulkEntitlementResponseInfo
func (a *EntitlementsApiService) BulkDeleteGDEEntitlementsExecute(r ApiBulkDeleteGDEEntitlementsRequest) ([]BulkEntitlementResponseInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BulkEntitlementResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsApiService.BulkDeleteGDEEntitlements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/global-desktop-entitlements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApplicationPoolEntitlementsRequest struct {
	ctx        _context.Context
	ApiService *EntitlementsApiService
	id         string
}

func (r ApiGetApplicationPoolEntitlementsRequest) Execute() (EntitlementInfo, *_nethttp.Response, error) {
	return r.ApiService.GetApplicationPoolEntitlementsExecute(r)
}

/*
GetApplicationPoolEntitlements Returns the IDs of users or groups entitled to a given application pool.

All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| POOL_VIEW | Caller should have permission to this privilege, on the associated access group of application pool.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiGetApplicationPoolEntitlementsRequest
*/
func (a *EntitlementsApiService) GetApplicationPoolEntitlements(ctx _context.Context, id string) ApiGetApplicationPoolEntitlementsRequest {
	return ApiGetApplicationPoolEntitlementsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return EntitlementInfo
func (a *EntitlementsApiService) GetApplicationPoolEntitlementsExecute(r ApiGetApplicationPoolEntitlementsRequest) (EntitlementInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EntitlementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsApiService.GetApplicationPoolEntitlements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/application-pools/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDesktopPoolEntitlementsRequest struct {
	ctx        _context.Context
	ApiService *EntitlementsApiService
	id         string
}

func (r ApiGetDesktopPoolEntitlementsRequest) Execute() (EntitlementInfo, *_nethttp.Response, error) {
	return r.ApiService.GetDesktopPoolEntitlementsExecute(r)
}

/*
GetDesktopPoolEntitlements Returns the IDs of users or groups entitled to a given desktop pool.

All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| POOL_VIEW | Caller should have permission to this privilege, on the associated access group of desktop pool.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiGetDesktopPoolEntitlementsRequest
*/
func (a *EntitlementsApiService) GetDesktopPoolEntitlements(ctx _context.Context, id string) ApiGetDesktopPoolEntitlementsRequest {
	return ApiGetDesktopPoolEntitlementsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return EntitlementInfo
func (a *EntitlementsApiService) GetDesktopPoolEntitlementsExecute(r ApiGetDesktopPoolEntitlementsRequest) (EntitlementInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EntitlementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsApiService.GetDesktopPoolEntitlements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/desktop-pools/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGAEEntitlementRequest struct {
	ctx        _context.Context
	ApiService *EntitlementsApiService
	id         string
}

func (r ApiGetGAEEntitlementRequest) Execute() (EntitlementInfo, *_nethttp.Response, error) {
	return r.ApiService.GetGAEEntitlementExecute(r)
}

/*
GetGAEEntitlement Gets the user or group entitlements for a Global Application Entitlement.

Note: CPA must be initialized for the pod for invoking this API.<br>Note that this API depends on internal cache. There may be a delay in new entities being reflected in the response.
All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| FEDERATED_LDAP_VIEW | Caller should have permission to this privilege, on the associated access group of global application entitlement.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiGetGAEEntitlementRequest
*/
func (a *EntitlementsApiService) GetGAEEntitlement(ctx _context.Context, id string) ApiGetGAEEntitlementRequest {
	return ApiGetGAEEntitlementRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return EntitlementInfo
func (a *EntitlementsApiService) GetGAEEntitlementExecute(r ApiGetGAEEntitlementRequest) (EntitlementInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EntitlementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsApiService.GetGAEEntitlement")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/global-application-entitlements/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGDEEntitlementRequest struct {
	ctx        _context.Context
	ApiService *EntitlementsApiService
	id         string
}

func (r ApiGetGDEEntitlementRequest) Execute() (EntitlementInfo, *_nethttp.Response, error) {
	return r.ApiService.GetGDEEntitlementExecute(r)
}

/*
GetGDEEntitlement Gets the user or group entitlements for a Global Desktop Entitlement.

Note: CPA must be initialized for the pod for invoking this API.<br>Note that this API depends on internal cache. There may be a delay in new entities being reflected in the response.
All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| FEDERATED_LDAP_VIEW | Caller should have permission to this privilege, on the associated access group of global desktop entitlement.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiGetGDEEntitlementRequest
*/
func (a *EntitlementsApiService) GetGDEEntitlement(ctx _context.Context, id string) ApiGetGDEEntitlementRequest {
	return ApiGetGDEEntitlementRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return EntitlementInfo
func (a *EntitlementsApiService) GetGDEEntitlementExecute(r ApiGetGDEEntitlementRequest) (EntitlementInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  EntitlementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsApiService.GetGDEEntitlement")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/global-desktop-entitlements/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApplicationPoolEntitlementsRequest struct {
	ctx        _context.Context
	ApiService *EntitlementsApiService
	filter     *string
	page       *int32
	size       *int32
}

// filter expression built using fields with &lt;b&gt;&#39;supported filters&#39;&lt;/b&gt; as described in output &lt;b&gt;model&lt;/b&gt; schema of this API.
func (r ApiListApplicationPoolEntitlementsRequest) Filter(filter string) ApiListApplicationPoolEntitlementsRequest {
	r.filter = &filter
	return r
}

// page, if passed should be &gt; 0.
func (r ApiListApplicationPoolEntitlementsRequest) Page(page int32) ApiListApplicationPoolEntitlementsRequest {
	r.page = &page
	return r
}

// size, if passed should be &gt; 0.
func (r ApiListApplicationPoolEntitlementsRequest) Size(size int32) ApiListApplicationPoolEntitlementsRequest {
	r.size = &size
	return r
}

func (r ApiListApplicationPoolEntitlementsRequest) Execute() ([]EntitlementInfo, *_nethttp.Response, error) {
	return r.ApiService.ListApplicationPoolEntitlementsExecute(r)
}

/*
ListApplicationPoolEntitlements Lists the entitlements for Application Pools in the environment.

This API supports <b>Pagination</b> and <b>Filters.</b><br/>For full information on using Filters, refer to 'Horizon Server REST Pagination and Filter Guide' of 'VMware Horizon Server API' in code.vmware.com
All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| POOL_VIEW | Returns results only for those application entitlements, for which the caller has permission to this privilege, on the associated access group of application pool.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListApplicationPoolEntitlementsRequest
*/
func (a *EntitlementsApiService) ListApplicationPoolEntitlements(ctx _context.Context) ApiListApplicationPoolEntitlementsRequest {
	return ApiListApplicationPoolEntitlementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []EntitlementInfo
func (a *EntitlementsApiService) ListApplicationPoolEntitlementsExecute(r ApiListApplicationPoolEntitlementsRequest) ([]EntitlementInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []EntitlementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsApiService.ListApplicationPoolEntitlements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/application-pools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDesktopPoolEntitlementsRequest struct {
	ctx        _context.Context
	ApiService *EntitlementsApiService
	filter     *string
	page       *int32
	size       *int32
}

// filter expression built using fields with &lt;b&gt;&#39;supported filters&#39;&lt;/b&gt; as described in output &lt;b&gt;model&lt;/b&gt; schema of this API.
func (r ApiListDesktopPoolEntitlementsRequest) Filter(filter string) ApiListDesktopPoolEntitlementsRequest {
	r.filter = &filter
	return r
}

// page, if passed should be &gt; 0.
func (r ApiListDesktopPoolEntitlementsRequest) Page(page int32) ApiListDesktopPoolEntitlementsRequest {
	r.page = &page
	return r
}

// size, if passed should be &gt; 0.
func (r ApiListDesktopPoolEntitlementsRequest) Size(size int32) ApiListDesktopPoolEntitlementsRequest {
	r.size = &size
	return r
}

func (r ApiListDesktopPoolEntitlementsRequest) Execute() ([]EntitlementInfo, *_nethttp.Response, error) {
	return r.ApiService.ListDesktopPoolEntitlementsExecute(r)
}

/*
ListDesktopPoolEntitlements Lists the entitlements for Desktop Pools in the environment.

This API supports <b>Pagination</b> and <b>Filters.</b><br/>For full information on using Filters, refer to 'Horizon Server REST Pagination and Filter Guide' of 'VMware Horizon Server API' in code.vmware.com
All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| POOL_VIEW | Returns results only for those desktop entitlements, for which the caller has permission to this privilege, on the associated access group of desktop pool.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDesktopPoolEntitlementsRequest
*/
func (a *EntitlementsApiService) ListDesktopPoolEntitlements(ctx _context.Context) ApiListDesktopPoolEntitlementsRequest {
	return ApiListDesktopPoolEntitlementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []EntitlementInfo
func (a *EntitlementsApiService) ListDesktopPoolEntitlementsExecute(r ApiListDesktopPoolEntitlementsRequest) ([]EntitlementInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []EntitlementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsApiService.ListDesktopPoolEntitlements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/desktop-pools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGAEEntitlementsRequest struct {
	ctx        _context.Context
	ApiService *EntitlementsApiService
	filter     *string
	page       *int32
	size       *int32
}

// filter expression built using fields with &lt;b&gt;&#39;supported filters&#39;&lt;/b&gt; as described in output &lt;b&gt;model&lt;/b&gt; schema of this API.
func (r ApiListGAEEntitlementsRequest) Filter(filter string) ApiListGAEEntitlementsRequest {
	r.filter = &filter
	return r
}

// page, if passed should be &gt; 0.
func (r ApiListGAEEntitlementsRequest) Page(page int32) ApiListGAEEntitlementsRequest {
	r.page = &page
	return r
}

// size, if passed should be &gt; 0.
func (r ApiListGAEEntitlementsRequest) Size(size int32) ApiListGAEEntitlementsRequest {
	r.size = &size
	return r
}

func (r ApiListGAEEntitlementsRequest) Execute() ([]EntitlementInfo, *_nethttp.Response, error) {
	return r.ApiService.ListGAEEntitlementsExecute(r)
}

/*
ListGAEEntitlements Lists the user or group entitlements for Global Application Entitlements in the environment.

Note: CPA must be initialized for the pod for invoking this API.<br/>Note that this API depends on internal cache. There may be a delay in new entities being reflected in the response.<br/>This API supports <b>Pagination</b> and <b>Filters.</b><br/>For full information on using Filters, refer to 'Horizon Server REST Pagination and Filter Guide' of 'VMware Horizon Server API' in code.vmware.com
All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| FEDERATED_LDAP_VIEW | Returns results only for those entitlements of global application entitlements, for which the caller has permission to this privilege, on the associated access group of global application entitlement.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGAEEntitlementsRequest
*/
func (a *EntitlementsApiService) ListGAEEntitlements(ctx _context.Context) ApiListGAEEntitlementsRequest {
	return ApiListGAEEntitlementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []EntitlementInfo
func (a *EntitlementsApiService) ListGAEEntitlementsExecute(r ApiListGAEEntitlementsRequest) ([]EntitlementInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []EntitlementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsApiService.ListGAEEntitlements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/global-application-entitlements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGDEEntitlementsRequest struct {
	ctx        _context.Context
	ApiService *EntitlementsApiService
	filter     *string
	page       *int32
	size       *int32
}

// filter expression built using fields with &lt;b&gt;&#39;supported filters&#39;&lt;/b&gt; as described in output &lt;b&gt;model&lt;/b&gt; schema of this API.
func (r ApiListGDEEntitlementsRequest) Filter(filter string) ApiListGDEEntitlementsRequest {
	r.filter = &filter
	return r
}

// page, if passed should be &gt; 0.
func (r ApiListGDEEntitlementsRequest) Page(page int32) ApiListGDEEntitlementsRequest {
	r.page = &page
	return r
}

// size, if passed should be &gt; 0.
func (r ApiListGDEEntitlementsRequest) Size(size int32) ApiListGDEEntitlementsRequest {
	r.size = &size
	return r
}

func (r ApiListGDEEntitlementsRequest) Execute() ([]EntitlementInfo, *_nethttp.Response, error) {
	return r.ApiService.ListGDEEntitlementsExecute(r)
}

/*
ListGDEEntitlements Lists the user or group entitlements for Global Desktop Entitlements in the environment.

Note: CPA must be initialized for the pod for invoking this API.<br/>Note that this API depends on internal cache. There may be a delay in new entities being reflected in the response.<br/>This API supports <b>Pagination</b> and <b>Filters.</b><br/>For full information on using Filters, refer to 'Horizon Server REST Pagination and Filter Guide' of 'VMware Horizon Server API' in code.vmware.com
All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| FEDERATED_LDAP_VIEW | Returns results only for those entitlements of global desktop entitlements, for which the caller has permission to this privilege, on the associated access group of global desktop entitlement.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGDEEntitlementsRequest
*/
func (a *EntitlementsApiService) ListGDEEntitlements(ctx _context.Context) ApiListGDEEntitlementsRequest {
	return ApiListGDEEntitlementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []EntitlementInfo
func (a *EntitlementsApiService) ListGDEEntitlementsExecute(r ApiListGDEEntitlementsRequest) ([]EntitlementInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []EntitlementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntitlementsApiService.ListGDEEntitlements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/entitlements/v1/global-desktop-entitlements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
