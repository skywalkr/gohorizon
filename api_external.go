/*
Horizon Server API

Welcome to the Horizon Server API Reference documentation. This API reference provides comprehensive information about status of all Horizon Server components and resources. <br> Choose Latest spec from dropdown to view API reference on latest version available.

API version: 2111
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package gohorizon

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"reflect"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ExternalApiService ExternalApi service
type ExternalApiService service

type ApiAddAuxiliaryAccountsRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	id         string
	body       *ADDomainAuxiliaryAccountCreateSpec
}

// Specification of auxiliary accounts.
func (r ApiAddAuxiliaryAccountsRequest) Body(body ADDomainAuxiliaryAccountCreateSpec) ApiAddAuxiliaryAccountsRequest {
	r.body = &body
	return r
}

func (r ApiAddAuxiliaryAccountsRequest) Execute() ([]BulkItemResponseInfo, *_nethttp.Response, error) {
	return r.ApiService.AddAuxiliaryAccountsExecute(r)
}

/*
AddAuxiliaryAccounts Add auxiliary accounts to the untrusted domain

All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_MANAGEMENT | Caller should have permission to this privilege to configure and manage untrusted domain.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiAddAuxiliaryAccountsRequest
*/
func (a *ExternalApiService) AddAuxiliaryAccounts(ctx _context.Context, id string) ApiAddAuxiliaryAccountsRequest {
	return ApiAddAuxiliaryAccountsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return []BulkItemResponseInfo
func (a *ExternalApiService) AddAuxiliaryAccountsExecute(r ApiAddAuxiliaryAccountsRequest) ([]BulkItemResponseInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BulkItemResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.AddAuxiliaryAccounts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains/{id}/action/add-auxiliary-accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuditEventsExtendedAttributesRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	ids        *[]int64
}

// Audit Event IDs
func (r ApiAuditEventsExtendedAttributesRequest) Ids(ids []int64) ApiAuditEventsExtendedAttributesRequest {
	r.ids = &ids
	return r
}

func (r ApiAuditEventsExtendedAttributesRequest) Execute() ([]AuditEventAttributeInfo, *_nethttp.Response, error) {
	return r.ApiService.AuditEventsExtendedAttributesExecute(r)
}

/*
AuditEventsExtendedAttributes Get extended attributes of audit events

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuditEventsExtendedAttributesRequest
*/
func (a *ExternalApiService) AuditEventsExtendedAttributes(ctx _context.Context) ApiAuditEventsExtendedAttributesRequest {
	return ApiAuditEventsExtendedAttributesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []AuditEventAttributeInfo
func (a *ExternalApiService) AuditEventsExtendedAttributesExecute(r ApiAuditEventsExtendedAttributesRequest) ([]AuditEventAttributeInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AuditEventAttributeInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.AuditEventsExtendedAttributes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/audit-events/extended-attributes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	{
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("ids", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("ids", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBindRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	body       *ADDomainSpec
}

// Specification of untrusted domain.
func (r ApiBindRequest) Body(body ADDomainSpec) ApiBindRequest {
	r.body = &body
	return r
}

func (r ApiBindRequest) Execute() (ADDomainBindInfo, *_nethttp.Response, error) {
	return r.ApiService.BindExecute(r)
}

/*
Bind Bind untrusted domain to the connection server.

All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_MANAGEMENT | Caller should have permission to this privilege to configure and manage untrusted domain.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBindRequest
*/
func (a *ExternalApiService) Bind(ctx _context.Context) ApiBindRequest {
	return ApiBindRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ADDomainBindInfo
func (a *ExternalApiService) BindExecute(r ApiBindRequest) (ADDomainBindInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ADDomainBindInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.Bind")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains/action/bind"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangeUserPasswordRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	body       *ADUserChangePasswordSpec
}

// AD user password object to be changed.
func (r ApiChangeUserPasswordRequest) Body(body ADUserChangePasswordSpec) ApiChangeUserPasswordRequest {
	r.body = &body
	return r
}

func (r ApiChangeUserPasswordRequest) Execute() (ADUserInfo, *_nethttp.Response, error) {
	return r.ApiService.ChangeUserPasswordExecute(r)
}

/*
ChangeUserPassword Changes the password of AD User

All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_MANAGEMENT | Caller should have permission to this privilege to change the password of AD User.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChangeUserPasswordRequest
*/
func (a *ExternalApiService) ChangeUserPassword(ctx _context.Context) ApiChangeUserPasswordRequest {
	return ApiChangeUserPasswordRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ADUserInfo
func (a *ExternalApiService) ChangeUserPasswordExecute(r ApiChangeUserPasswordRequest) (ADUserInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ADUserInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ChangeUserPassword")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-users-or-groups/action/change-user-password"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeSpaceRequirementsRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	body       *DatastoreSpaceRequirementSpec
}

// Datastore space requirement to be computed.
func (r ApiComputeSpaceRequirementsRequest) Body(body DatastoreSpaceRequirementSpec) ApiComputeSpaceRequirementsRequest {
	r.body = &body
	return r
}

func (r ApiComputeSpaceRequirementsRequest) Execute() ([]DatastoreSpaceRequirementInfo, *_nethttp.Response, error) {
	return r.ApiService.ComputeSpaceRequirementsExecute(r)
}

/*
ComputeSpaceRequirements Computes the datastore space requirements for inventory resources.

All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| POOL_VIEW | Caller should have permission to this privilege, on the associated desktop or farm.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiComputeSpaceRequirementsRequest
*/
func (a *ExternalApiService) ComputeSpaceRequirements(ctx _context.Context) ApiComputeSpaceRequirementsRequest {
	return ApiComputeSpaceRequirementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []DatastoreSpaceRequirementInfo
func (a *ExternalApiService) ComputeSpaceRequirementsExecute(r ApiComputeSpaceRequirementsRequest) ([]DatastoreSpaceRequirementInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []DatastoreSpaceRequirementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ComputeSpaceRequirements")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/datastores/action/compute-requirements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAuxiliaryAccountsRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	id         string
	body       *ADDomainAuxiliaryAccountDeleteSpec
}

// Auxiliary accounts to delete.
func (r ApiDeleteAuxiliaryAccountsRequest) Body(body ADDomainAuxiliaryAccountDeleteSpec) ApiDeleteAuxiliaryAccountsRequest {
	r.body = &body
	return r
}

func (r ApiDeleteAuxiliaryAccountsRequest) Execute() ([]BulkItemResponseInfo, *_nethttp.Response, error) {
	return r.ApiService.DeleteAuxiliaryAccountsExecute(r)
}

/*
DeleteAuxiliaryAccounts Specification to delete auxiliary accounts from the untrusted domain

All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_MANAGEMENT | Caller should have permission to this privilege to configure and manage untrusted domain.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiDeleteAuxiliaryAccountsRequest
*/
func (a *ExternalApiService) DeleteAuxiliaryAccounts(ctx _context.Context, id string) ApiDeleteAuxiliaryAccountsRequest {
	return ApiDeleteAuxiliaryAccountsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return []BulkItemResponseInfo
func (a *ExternalApiService) DeleteAuxiliaryAccountsExecute(r ApiDeleteAuxiliaryAccountsRequest) ([]BulkItemResponseInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BulkItemResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.DeleteAuxiliaryAccounts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains/{id}/action/delete-auxiliary-accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetADUserOrGroupInfoRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	id         string
}

func (r ApiGetADUserOrGroupInfoRequest) Execute() (ADUserOrGroupInfo, *_nethttp.Response, error) {
	return r.ApiService.GetADUserOrGroupInfoExecute(r)
}

/*
GetADUserOrGroupInfo Get information related to AD User or Group

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiGetADUserOrGroupInfoRequest
*/
func (a *ExternalApiService) GetADUserOrGroupInfo(ctx _context.Context, id string) ApiGetADUserOrGroupInfoRequest {
	return ApiGetADUserOrGroupInfoRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//  @return ADUserOrGroupInfo
func (a *ExternalApiService) GetADUserOrGroupInfoExecute(r ApiGetADUserOrGroupInfoRequest) (ADUserOrGroupInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ADUserOrGroupInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.GetADUserOrGroupInfo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-users-or-groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListADDomainsRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
}

func (r ApiListADDomainsRequest) Execute() ([]ADDomainInfo, *_nethttp.Response, error) {
	return r.ApiService.ListADDomainsExecute(r)
}

/*
ListADDomains Lists information related to AD Domains of the environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListADDomainsRequest
*/
func (a *ExternalApiService) ListADDomains(ctx _context.Context) ApiListADDomainsRequest {
	return ApiListADDomainsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []ADDomainInfo
func (a *ExternalApiService) ListADDomainsExecute(r ApiListADDomainsRequest) ([]ADDomainInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ADDomainInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListADDomains")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListADDomainsV2Request struct {
	ctx        _context.Context
	ApiService *ExternalApiService
}

func (r ApiListADDomainsV2Request) Execute() ([]ADDomainInfoV2, *_nethttp.Response, error) {
	return r.ApiService.ListADDomainsV2Execute(r)
}

/*
ListADDomainsV2 Lists information related to AD Domains of the environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListADDomainsV2Request
*/
func (a *ExternalApiService) ListADDomainsV2(ctx _context.Context) ApiListADDomainsV2Request {
	return ApiListADDomainsV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []ADDomainInfoV2
func (a *ExternalApiService) ListADDomainsV2Execute(r ApiListADDomainsV2Request) ([]ADDomainInfoV2, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ADDomainInfoV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListADDomainsV2")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v2/ad-domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListADDomainsV3Request struct {
	ctx        _context.Context
	ApiService *ExternalApiService
}

func (r ApiListADDomainsV3Request) Execute() ([]ADDomainInfoV3, *_nethttp.Response, error) {
	return r.ApiService.ListADDomainsV3Execute(r)
}

/*
ListADDomainsV3 Lists information related to AD Domains of the environment.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListADDomainsV3Request
*/
func (a *ExternalApiService) ListADDomainsV3(ctx _context.Context) ApiListADDomainsV3Request {
	return ApiListADDomainsV3Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []ADDomainInfoV3
func (a *ExternalApiService) ListADDomainsV3Execute(r ApiListADDomainsV3Request) ([]ADDomainInfoV3, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ADDomainInfoV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListADDomainsV3")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v3/ad-domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListADUserOrGroupSummaryRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	filter     *string
	groupOnly  *string
	page       *int32
	size       *int32
}

// filter expression built using fields with &lt;b&gt;&#39;supported filters&#39;&lt;/b&gt; as described in output &lt;b&gt;model&lt;/b&gt; schema of this API.
func (r ApiListADUserOrGroupSummaryRequest) Filter(filter string) ApiListADUserOrGroupSummaryRequest {
	r.filter = &filter
	return r
}

// Presence of this query param indicates to filter only groups or only users.   If passed as \&quot;true\&quot;, then only groups are returned.  If passed as \&quot;false\&quot;, then only users are returned.  If not passed passed at all, then both types are returned.
func (r ApiListADUserOrGroupSummaryRequest) GroupOnly(groupOnly string) ApiListADUserOrGroupSummaryRequest {
	r.groupOnly = &groupOnly
	return r
}

// page, if passed should be &gt; 0.
func (r ApiListADUserOrGroupSummaryRequest) Page(page int32) ApiListADUserOrGroupSummaryRequest {
	r.page = &page
	return r
}

// size, if passed should be &gt; 0.
func (r ApiListADUserOrGroupSummaryRequest) Size(size int32) ApiListADUserOrGroupSummaryRequest {
	r.size = &size
	return r
}

func (r ApiListADUserOrGroupSummaryRequest) Execute() ([]ADUserOrGroupSummary, *_nethttp.Response, error) {
	return r.ApiService.ListADUserOrGroupSummaryExecute(r)
}

/*
ListADUserOrGroupSummary Lists AD users or groups information.

This API supports <b>Pagination</b> and <b>Filters.</b><br/>For full information on using Filters, refer to 'Horizon Server REST Pagination and Filter Guide' of 'VMware Horizon Server API' in code.vmware.com

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListADUserOrGroupSummaryRequest
*/
func (a *ExternalApiService) ListADUserOrGroupSummary(ctx _context.Context) ApiListADUserOrGroupSummaryRequest {
	return ApiListADUserOrGroupSummaryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []ADUserOrGroupSummary
func (a *ExternalApiService) ListADUserOrGroupSummaryExecute(r ApiListADUserOrGroupSummaryRequest) ([]ADUserOrGroupSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ADUserOrGroupSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListADUserOrGroupSummary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-users-or-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.groupOnly != nil {
		localVarQueryParams.Add("group_only", parameterToString(*r.groupOnly, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAuditEventsRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	filter     *string
	page       *int32
	size       *int32
}

// filter expression built using fields with &lt;b&gt;&#39;supported filters&#39;&lt;/b&gt; as described in output &lt;b&gt;model&lt;/b&gt; schema of this API.
func (r ApiListAuditEventsRequest) Filter(filter string) ApiListAuditEventsRequest {
	r.filter = &filter
	return r
}

// page, if passed should be &gt; 0.
func (r ApiListAuditEventsRequest) Page(page int32) ApiListAuditEventsRequest {
	r.page = &page
	return r
}

// size, if passed should be &gt; 0.
func (r ApiListAuditEventsRequest) Size(size int32) ApiListAuditEventsRequest {
	r.size = &size
	return r
}

func (r ApiListAuditEventsRequest) Execute() ([]AuditEventSummary, *_nethttp.Response, error) {
	return r.ApiService.ListAuditEventsExecute(r)
}

/*
ListAuditEvents Lists the audit events.

This API supports <b>Pagination</b>.<br/>

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAuditEventsRequest
*/
func (a *ExternalApiService) ListAuditEvents(ctx _context.Context) ApiListAuditEventsRequest {
	return ApiListAuditEventsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []AuditEventSummary
func (a *ExternalApiService) ListAuditEventsExecute(r ApiListAuditEventsRequest) ([]AuditEventSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AuditEventSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListAuditEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/audit-events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBaseSnapshotsRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	baseVmId   *string
	vcenterId  *string
}

// VM ID
func (r ApiListBaseSnapshotsRequest) BaseVmId(baseVmId string) ApiListBaseSnapshotsRequest {
	r.baseVmId = &baseVmId
	return r
}

// Virtual Center ID
func (r ApiListBaseSnapshotsRequest) VcenterId(vcenterId string) ApiListBaseSnapshotsRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListBaseSnapshotsRequest) Execute() ([]BaseSnapshotInfo, *_nethttp.Response, error) {
	return r.ApiService.ListBaseSnapshotsExecute(r)
}

/*
ListBaseSnapshots Lists all the VM snapshots from the vCenter for a given VM.

At least one of the listed privileges is required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBaseSnapshotsRequest
*/
func (a *ExternalApiService) ListBaseSnapshots(ctx _context.Context) ApiListBaseSnapshotsRequest {
	return ApiListBaseSnapshotsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []BaseSnapshotInfo
func (a *ExternalApiService) ListBaseSnapshotsExecute(r ApiListBaseSnapshotsRequest) ([]BaseSnapshotInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BaseSnapshotInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListBaseSnapshots")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/base-snapshots"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.baseVmId == nil {
		return localVarReturnValue, nil, reportError("baseVmId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	localVarQueryParams.Add("base_vm_id", parameterToString(*r.baseVmId, ""))
	localVarQueryParams.Add("vcenter_id", parameterToString(*r.vcenterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBaseVMsRequest struct {
	ctx                   _context.Context
	ApiService            *ExternalApiService
	vcenterId             *string
	datacenterId          *string
	filterIncompatibleVms *bool
}

// Virtual Center ID
func (r ApiListBaseVMsRequest) VcenterId(vcenterId string) ApiListBaseVMsRequest {
	r.vcenterId = &vcenterId
	return r
}

// Datacenter ID
func (r ApiListBaseVMsRequest) DatacenterId(datacenterId string) ApiListBaseVMsRequest {
	r.datacenterId = &datacenterId
	return r
}

// Whether to filter out incompatible VMs
func (r ApiListBaseVMsRequest) FilterIncompatibleVms(filterIncompatibleVms bool) ApiListBaseVMsRequest {
	r.filterIncompatibleVms = &filterIncompatibleVms
	return r
}

func (r ApiListBaseVMsRequest) Execute() ([]BaseVMInfo, *_nethttp.Response, error) {
	return r.ApiService.ListBaseVMsExecute(r)
}

/*
ListBaseVMs Lists all the VMs from a vCenter or a datacenter in that vCenter which may be suitable as snapshots for instant clone desktop pool or farm creation.

At least one of the listed privileges is required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBaseVMsRequest
*/
func (a *ExternalApiService) ListBaseVMs(ctx _context.Context) ApiListBaseVMsRequest {
	return ApiListBaseVMsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []BaseVMInfo
func (a *ExternalApiService) ListBaseVMsExecute(r ApiListBaseVMsRequest) ([]BaseVMInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BaseVMInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListBaseVMs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/base-vms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	if r.datacenterId != nil {
		localVarQueryParams.Add("datacenter_id", parameterToString(*r.datacenterId, ""))
	}
	if r.filterIncompatibleVms != nil {
		localVarQueryParams.Add("filter_incompatible_vms", parameterToString(*r.filterIncompatibleVms, ""))
	}
	localVarQueryParams.Add("vcenter_id", parameterToString(*r.vcenterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCustomizationSpecsRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	vcenterId  *string
}

// Virtual Center ID
func (r ApiListCustomizationSpecsRequest) VcenterId(vcenterId string) ApiListCustomizationSpecsRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListCustomizationSpecsRequest) Execute() ([]CustomizationSpecInfo, *_nethttp.Response, error) {
	return r.ApiService.ListCustomizationSpecsExecute(r)
}

/*
ListCustomizationSpecs Lists all the customization specifications from the vCenter.

At least one of the listed privileges is required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCustomizationSpecsRequest
*/
func (a *ExternalApiService) ListCustomizationSpecs(ctx _context.Context) ApiListCustomizationSpecsRequest {
	return ApiListCustomizationSpecsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []CustomizationSpecInfo
func (a *ExternalApiService) ListCustomizationSpecsExecute(r ApiListCustomizationSpecsRequest) ([]CustomizationSpecInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []CustomizationSpecInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListCustomizationSpecs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/customization-specifications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	localVarQueryParams.Add("vcenter_id", parameterToString(*r.vcenterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDatacentersRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	vcenterId  *string
}

// Virtual Center ID
func (r ApiListDatacentersRequest) VcenterId(vcenterId string) ApiListDatacentersRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListDatacentersRequest) Execute() ([]DatacenterInfo, *_nethttp.Response, error) {
	return r.ApiService.ListDatacentersExecute(r)
}

/*
ListDatacenters Lists all the datacenters of a vCenter.

All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDatacentersRequest
*/
func (a *ExternalApiService) ListDatacenters(ctx _context.Context) ApiListDatacentersRequest {
	return ApiListDatacentersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []DatacenterInfo
func (a *ExternalApiService) ListDatacentersExecute(r ApiListDatacentersRequest) ([]DatacenterInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []DatacenterInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListDatacenters")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/datacenters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	localVarQueryParams.Add("vcenter_id", parameterToString(*r.vcenterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDatastoreClustersRequest struct {
	ctx             _context.Context
	ApiService      *ExternalApiService
	hostOrClusterId *string
	vcenterId       *string
}

// Host or Cluster ID
func (r ApiListDatastoreClustersRequest) HostOrClusterId(hostOrClusterId string) ApiListDatastoreClustersRequest {
	r.hostOrClusterId = &hostOrClusterId
	return r
}

// Virtual Center ID
func (r ApiListDatastoreClustersRequest) VcenterId(vcenterId string) ApiListDatastoreClustersRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListDatastoreClustersRequest) Execute() ([]DatastoreClusterInfo, *_nethttp.Response, error) {
	return r.ApiService.ListDatastoreClustersExecute(r)
}

/*
ListDatastoreClusters Lists all the datastore clusters from the vCenter for the given host or cluster.

At least one of the listed privileges is required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDatastoreClustersRequest
*/
func (a *ExternalApiService) ListDatastoreClusters(ctx _context.Context) ApiListDatastoreClustersRequest {
	return ApiListDatastoreClustersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []DatastoreClusterInfo
func (a *ExternalApiService) ListDatastoreClustersExecute(r ApiListDatastoreClustersRequest) ([]DatastoreClusterInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []DatastoreClusterInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListDatastoreClusters")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/datastore-clusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.hostOrClusterId == nil {
		return localVarReturnValue, nil, reportError("hostOrClusterId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	localVarQueryParams.Add("host_or_cluster_id", parameterToString(*r.hostOrClusterId, ""))
	localVarQueryParams.Add("vcenter_id", parameterToString(*r.vcenterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDatastorePathsRequest struct {
	ctx         _context.Context
	ApiService  *ExternalApiService
	datastoreId *string
	vcenterId   *string
}

// Datastore ID
func (r ApiListDatastorePathsRequest) DatastoreId(datastoreId string) ApiListDatastorePathsRequest {
	r.datastoreId = &datastoreId
	return r
}

// Virtual Center ID
func (r ApiListDatastorePathsRequest) VcenterId(vcenterId string) ApiListDatastorePathsRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListDatastorePathsRequest) Execute() ([]DatastorePathInfo, *_nethttp.Response, error) {
	return r.ApiService.ListDatastorePathsExecute(r)
}

/*
ListDatastorePaths Lists all the folder paths within a Datastore from vCenter.

At least one of the listed privileges is required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDatastorePathsRequest
*/
func (a *ExternalApiService) ListDatastorePaths(ctx _context.Context) ApiListDatastorePathsRequest {
	return ApiListDatastorePathsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []DatastorePathInfo
func (a *ExternalApiService) ListDatastorePathsExecute(r ApiListDatastorePathsRequest) ([]DatastorePathInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []DatastorePathInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListDatastorePaths")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/datastore-paths"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.datastoreId == nil {
		return localVarReturnValue, nil, reportError("datastoreId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	localVarQueryParams.Add("datastore_id", parameterToString(*r.datastoreId, ""))
	localVarQueryParams.Add("vcenter_id", parameterToString(*r.vcenterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListHostsOrClustersRequest struct {
	ctx          _context.Context
	ApiService   *ExternalApiService
	datacenterId *string
	vcenterId    *string
}

// Datacenter ID
func (r ApiListHostsOrClustersRequest) DatacenterId(datacenterId string) ApiListHostsOrClustersRequest {
	r.datacenterId = &datacenterId
	return r
}

// Virtual Center ID
func (r ApiListHostsOrClustersRequest) VcenterId(vcenterId string) ApiListHostsOrClustersRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListHostsOrClustersRequest) Execute() ([]HostOrClusterInfo, *_nethttp.Response, error) {
	return r.ApiService.ListHostsOrClustersExecute(r)
}

/*
ListHostsOrClusters Lists all the hosts or clusters of the datacenter.

At least one of the listed privileges is required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListHostsOrClustersRequest
*/
func (a *ExternalApiService) ListHostsOrClusters(ctx _context.Context) ApiListHostsOrClustersRequest {
	return ApiListHostsOrClustersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []HostOrClusterInfo
func (a *ExternalApiService) ListHostsOrClustersExecute(r ApiListHostsOrClustersRequest) ([]HostOrClusterInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []HostOrClusterInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListHostsOrClusters")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/hosts-or-clusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.datacenterId == nil {
		return localVarReturnValue, nil, reportError("datacenterId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	localVarQueryParams.Add("datacenter_id", parameterToString(*r.datacenterId, ""))
	localVarQueryParams.Add("vcenter_id", parameterToString(*r.vcenterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListNetworkInterfaceCardsRequest struct {
	ctx            _context.Context
	ApiService     *ExternalApiService
	vcenterId      *string
	baseSnapshotId *string
	baseVmId       *string
	vmTemplateId   *string
}

// Virtual Center ID
func (r ApiListNetworkInterfaceCardsRequest) VcenterId(vcenterId string) ApiListNetworkInterfaceCardsRequest {
	r.vcenterId = &vcenterId
	return r
}

// Base Snapshot ID
func (r ApiListNetworkInterfaceCardsRequest) BaseSnapshotId(baseSnapshotId string) ApiListNetworkInterfaceCardsRequest {
	r.baseSnapshotId = &baseSnapshotId
	return r
}

// Base VM ID
func (r ApiListNetworkInterfaceCardsRequest) BaseVmId(baseVmId string) ApiListNetworkInterfaceCardsRequest {
	r.baseVmId = &baseVmId
	return r
}

// VM Template ID
func (r ApiListNetworkInterfaceCardsRequest) VmTemplateId(vmTemplateId string) ApiListNetworkInterfaceCardsRequest {
	r.vmTemplateId = &vmTemplateId
	return r
}

func (r ApiListNetworkInterfaceCardsRequest) Execute() ([]NetworkInterfaceCardInfo, *_nethttp.Response, error) {
	return r.ApiService.ListNetworkInterfaceCardsExecute(r)
}

/*
ListNetworkInterfaceCards Returns a list of network interface cards (NICs) suitable for configuration on a desktop pool/farm.

If the base VM and snapshot are specified, then the NICs  present on the given snapshot are listed.<br/> If the template is specified then the NICs present on the given template are listed.<br/>At least one of the listed privileges is required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListNetworkInterfaceCardsRequest
*/
func (a *ExternalApiService) ListNetworkInterfaceCards(ctx _context.Context) ApiListNetworkInterfaceCardsRequest {
	return ApiListNetworkInterfaceCardsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []NetworkInterfaceCardInfo
func (a *ExternalApiService) ListNetworkInterfaceCardsExecute(r ApiListNetworkInterfaceCardsRequest) ([]NetworkInterfaceCardInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []NetworkInterfaceCardInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListNetworkInterfaceCards")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/network-interface-cards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	if r.baseSnapshotId != nil {
		localVarQueryParams.Add("base_snapshot_id", parameterToString(*r.baseSnapshotId, ""))
	}
	if r.baseVmId != nil {
		localVarQueryParams.Add("base_vm_id", parameterToString(*r.baseVmId, ""))
	}
	localVarQueryParams.Add("vcenter_id", parameterToString(*r.vcenterId, ""))
	if r.vmTemplateId != nil {
		localVarQueryParams.Add("vm_template_id", parameterToString(*r.vmTemplateId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListNetworkLabelsRequest struct {
	ctx             _context.Context
	ApiService      *ExternalApiService
	hostOrClusterId *string
	vcenterId       *string
	networkType     *string
}

// Host or Cluster ID
func (r ApiListNetworkLabelsRequest) HostOrClusterId(hostOrClusterId string) ApiListNetworkLabelsRequest {
	r.hostOrClusterId = &hostOrClusterId
	return r
}

// Virtual Center ID
func (r ApiListNetworkLabelsRequest) VcenterId(vcenterId string) ApiListNetworkLabelsRequest {
	r.vcenterId = &vcenterId
	return r
}

// Network Type * NETWORK: Standard network. * OPAQUE_NETWORK: Opaque network. * DISTRUBUTED_VIRTUAL_PORT_GROUP: DVS Port group.
func (r ApiListNetworkLabelsRequest) NetworkType(networkType string) ApiListNetworkLabelsRequest {
	r.networkType = &networkType
	return r
}

func (r ApiListNetworkLabelsRequest) Execute() ([]NetworkLabelInfo, *_nethttp.Response, error) {
	return r.ApiService.ListNetworkLabelsExecute(r)
}

/*
ListNetworkLabels Retrieves all network labels on the given host or cluster

API retrieves by filtering on the network type (if specified) that may be suitable for configuration with a desktop pool/farm's network interface card.<br/>At least one of the listed privileges is required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListNetworkLabelsRequest
*/
func (a *ExternalApiService) ListNetworkLabels(ctx _context.Context) ApiListNetworkLabelsRequest {
	return ApiListNetworkLabelsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []NetworkLabelInfo
func (a *ExternalApiService) ListNetworkLabelsExecute(r ApiListNetworkLabelsRequest) ([]NetworkLabelInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []NetworkLabelInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListNetworkLabels")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/network-labels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.hostOrClusterId == nil {
		return localVarReturnValue, nil, reportError("hostOrClusterId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	localVarQueryParams.Add("host_or_cluster_id", parameterToString(*r.hostOrClusterId, ""))
	if r.networkType != nil {
		localVarQueryParams.Add("network_type", parameterToString(*r.networkType, ""))
	}
	localVarQueryParams.Add("vcenter_id", parameterToString(*r.vcenterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListResourcePoolsRequest struct {
	ctx             _context.Context
	ApiService      *ExternalApiService
	hostOrClusterId *string
	vcenterId       *string
}

// Host or Cluster ID
func (r ApiListResourcePoolsRequest) HostOrClusterId(hostOrClusterId string) ApiListResourcePoolsRequest {
	r.hostOrClusterId = &hostOrClusterId
	return r
}

// Virtual Center ID
func (r ApiListResourcePoolsRequest) VcenterId(vcenterId string) ApiListResourcePoolsRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListResourcePoolsRequest) Execute() ([]ResourcePoolInfo, *_nethttp.Response, error) {
	return r.ApiService.ListResourcePoolsExecute(r)
}

/*
ListResourcePools Lists all the resource pools from the vCenter for the given host or cluster.

At least one of the listed privileges is required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListResourcePoolsRequest
*/
func (a *ExternalApiService) ListResourcePools(ctx _context.Context) ApiListResourcePoolsRequest {
	return ApiListResourcePoolsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []ResourcePoolInfo
func (a *ExternalApiService) ListResourcePoolsExecute(r ApiListResourcePoolsRequest) ([]ResourcePoolInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ResourcePoolInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListResourcePools")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/resource-pools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.hostOrClusterId == nil {
		return localVarReturnValue, nil, reportError("hostOrClusterId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	localVarQueryParams.Add("host_or_cluster_id", parameterToString(*r.hostOrClusterId, ""))
	localVarQueryParams.Add("vcenter_id", parameterToString(*r.vcenterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVMFoldersRequest struct {
	ctx          _context.Context
	ApiService   *ExternalApiService
	datacenterId *string
	vcenterId    *string
}

// Datacenter ID
func (r ApiListVMFoldersRequest) DatacenterId(datacenterId string) ApiListVMFoldersRequest {
	r.datacenterId = &datacenterId
	return r
}

// Virtual Center ID
func (r ApiListVMFoldersRequest) VcenterId(vcenterId string) ApiListVMFoldersRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListVMFoldersRequest) Execute() ([]VMFolderInfo, *_nethttp.Response, error) {
	return r.ApiService.ListVMFoldersExecute(r)
}

/*
ListVMFolders Lists all the VM folders from the vCenter for the given datacenter.

At least one of the listed privileges is required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListVMFoldersRequest
*/
func (a *ExternalApiService) ListVMFolders(ctx _context.Context) ApiListVMFoldersRequest {
	return ApiListVMFoldersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []VMFolderInfo
func (a *ExternalApiService) ListVMFoldersExecute(r ApiListVMFoldersRequest) ([]VMFolderInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []VMFolderInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListVMFolders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/vm-folders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.datacenterId == nil {
		return localVarReturnValue, nil, reportError("datacenterId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	localVarQueryParams.Add("datacenter_id", parameterToString(*r.datacenterId, ""))
	localVarQueryParams.Add("vcenter_id", parameterToString(*r.vcenterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVMTemplatesRequest struct {
	ctx          _context.Context
	ApiService   *ExternalApiService
	vcenterId    *string
	datacenterId *string
}

// Virtual Center ID
func (r ApiListVMTemplatesRequest) VcenterId(vcenterId string) ApiListVMTemplatesRequest {
	r.vcenterId = &vcenterId
	return r
}

// Datacenter ID
func (r ApiListVMTemplatesRequest) DatacenterId(datacenterId string) ApiListVMTemplatesRequest {
	r.datacenterId = &datacenterId
	return r
}

func (r ApiListVMTemplatesRequest) Execute() ([]VMTemplateInfo, *_nethttp.Response, error) {
	return r.ApiService.ListVMTemplatesExecute(r)
}

/*
ListVMTemplates Lists all the VM templates from a vCenter or a datacenter for the given vCenter which may be suitable for full clone desktop pool creation.

At least one of the listed privileges is required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListVMTemplatesRequest
*/
func (a *ExternalApiService) ListVMTemplates(ctx _context.Context) ApiListVMTemplatesRequest {
	return ApiListVMTemplatesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []VMTemplateInfo
func (a *ExternalApiService) ListVMTemplatesExecute(r ApiListVMTemplatesRequest) ([]VMTemplateInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []VMTemplateInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListVMTemplates")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/vm-templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	if r.datacenterId != nil {
		localVarQueryParams.Add("datacenter_id", parameterToString(*r.datacenterId, ""))
	}
	localVarQueryParams.Add("vcenter_id", parameterToString(*r.vcenterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVirtualMachinesRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	vcenterId  *string
}

// Virtual Center ID
func (r ApiListVirtualMachinesRequest) VcenterId(vcenterId string) ApiListVirtualMachinesRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListVirtualMachinesRequest) Execute() ([]VirtualMachineInfo, *_nethttp.Response, error) {
	return r.ApiService.ListVirtualMachinesExecute(r)
}

/*
ListVirtualMachines Lists all the VMs from a vCenter.

At least one of the listed privileges is required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListVirtualMachinesRequest
*/
func (a *ExternalApiService) ListVirtualMachines(ctx _context.Context) ApiListVirtualMachinesRequest {
	return ApiListVirtualMachinesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []VirtualMachineInfo
func (a *ExternalApiService) ListVirtualMachinesExecute(r ApiListVirtualMachinesRequest) ([]VirtualMachineInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []VirtualMachineInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ListVirtualMachines")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/virtual-machines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	localVarQueryParams.Add("vcenter_id", parameterToString(*r.vcenterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListdatastoresRequest struct {
	ctx             _context.Context
	ApiService      *ExternalApiService
	hostOrClusterId *string
	vcenterId       *string
}

// Host or Cluster ID
func (r ApiListdatastoresRequest) HostOrClusterId(hostOrClusterId string) ApiListdatastoresRequest {
	r.hostOrClusterId = &hostOrClusterId
	return r
}

// Virtual Center ID
func (r ApiListdatastoresRequest) VcenterId(vcenterId string) ApiListdatastoresRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListdatastoresRequest) Execute() ([]DatastoreInfo, *_nethttp.Response, error) {
	return r.ApiService.ListdatastoresExecute(r)
}

/*
Listdatastores Lists all the datastores from the vCenter for the given host or cluster.

At least one of the listed privileges is required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListdatastoresRequest
*/
func (a *ExternalApiService) Listdatastores(ctx _context.Context) ApiListdatastoresRequest {
	return ApiListdatastoresRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []DatastoreInfo
func (a *ExternalApiService) ListdatastoresExecute(r ApiListdatastoresRequest) ([]DatastoreInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []DatastoreInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.Listdatastores")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/datastores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.hostOrClusterId == nil {
		return localVarReturnValue, nil, reportError("hostOrClusterId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	localVarQueryParams.Add("host_or_cluster_id", parameterToString(*r.hostOrClusterId, ""))
	localVarQueryParams.Add("vcenter_id", parameterToString(*r.vcenterId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnbindRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	id         string
}

func (r ApiUnbindRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UnbindExecute(r)
}

/*
Unbind Unbind untrusted domain from the connection server.

All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_MANAGEMENT | Caller should have permission to this privilege to configure and manage untrusted domain.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiUnbindRequest
*/
func (a *ExternalApiService) Unbind(ctx _context.Context, id string) ApiUnbindRequest {
	return ApiUnbindRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *ExternalApiService) UnbindExecute(r ApiUnbindRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.Unbind")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains/{id}/action/unbind"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	id         string
	body       *ADDomainUpdateSpec
}

// Untrusted domain object to be updated.
func (r ApiUpdateRequest) Body(body ADDomainUpdateSpec) ApiUpdateRequest {
	r.body = &body
	return r
}

func (r ApiUpdateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateExecute(r)
}

/*
Update Updates untrusted domain.

All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_MANAGEMENT | Caller should have permission to this privilege to configure and manage untrusted domain.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiUpdateRequest
*/
func (a *ExternalApiService) Update(ctx _context.Context, id string) ApiUpdateRequest {
	return ApiUpdateRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *ExternalApiService) UpdateExecute(r ApiUpdateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.Update")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains/{id}/action/update"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAuxiliaryAccountsRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	body       *ADDomainAuxiliaryAccountUpdateSpec
}

// Specification to update auxiliary accounts.
func (r ApiUpdateAuxiliaryAccountsRequest) Body(body ADDomainAuxiliaryAccountUpdateSpec) ApiUpdateAuxiliaryAccountsRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAuxiliaryAccountsRequest) Execute() ([]BulkItemResponseInfo, *_nethttp.Response, error) {
	return r.ApiService.UpdateAuxiliaryAccountsExecute(r)
}

/*
UpdateAuxiliaryAccounts Update auxiliary accounts of the untrusted domain

All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_MANAGEMENT | Caller should have permission to this privilege to configure and manage untrusted domain.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAuxiliaryAccountsRequest
*/
func (a *ExternalApiService) UpdateAuxiliaryAccounts(ctx _context.Context) ApiUpdateAuxiliaryAccountsRequest {
	return ApiUpdateAuxiliaryAccountsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []BulkItemResponseInfo
func (a *ExternalApiService) UpdateAuxiliaryAccountsExecute(r ApiUpdateAuxiliaryAccountsRequest) ([]BulkItemResponseInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []BulkItemResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.UpdateAuxiliaryAccounts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains/action/update-auxiliary-accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateADUserEncryptedCredentialsRequest struct {
	ctx        _context.Context
	ApiService *ExternalApiService
	body       *ADUserEncryptedCredentialSpec
}

// AD user encrypted credentials object to be validated.
func (r ApiValidateADUserEncryptedCredentialsRequest) Body(body ADUserEncryptedCredentialSpec) ApiValidateADUserEncryptedCredentialsRequest {
	r.body = &body
	return r
}

func (r ApiValidateADUserEncryptedCredentialsRequest) Execute() (ADUserInfo, *_nethttp.Response, error) {
	return r.ApiService.ValidateADUserEncryptedCredentialsExecute(r)
}

/*
ValidateADUserEncryptedCredentials Validates the encrypted credentials of AD User

All the listed privileges are required -
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_MANAGEMENT | Caller should have permission to this privilege to validate the encrypted credentials of AD User.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateADUserEncryptedCredentialsRequest
*/
func (a *ExternalApiService) ValidateADUserEncryptedCredentials(ctx _context.Context) ApiValidateADUserEncryptedCredentialsRequest {
	return ApiValidateADUserEncryptedCredentialsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ADUserInfo
func (a *ExternalApiService) ValidateADUserEncryptedCredentialsExecute(r ApiValidateADUserEncryptedCredentialsRequest) (ADUserInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ADUserInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalApiService.ValidateADUserEncryptedCredentials")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-users-or-groups/action/validate-user-encrypted-credentials"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
