/*
Horizon Server API

Welcome to the Horizon Server API Reference documentation. This API reference provides comprehensive information about status of all Horizon Server components and resources. <br> Choose Latest spec from dropdown to view API reference on latest version available.

API version: 2212
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package gohorizon

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ExternalAPIService ExternalAPI service
type ExternalAPIService service

type ApiAddAuxiliaryAccountsRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	id string
	body *ADDomainAuxiliaryAccountCreateSpec
}

// Specification of auxiliary accounts.
func (r ApiAddAuxiliaryAccountsRequest) Body(body ADDomainAuxiliaryAccountCreateSpec) ApiAddAuxiliaryAccountsRequest {
	r.body = &body
	return r
}

func (r ApiAddAuxiliaryAccountsRequest) Execute() ([]BulkItemResponseInfo, *http.Response, error) {
	return r.ApiService.AddAuxiliaryAccountsExecute(r)
}

/*
AddAuxiliaryAccounts Add auxiliary accounts to the untrusted domain

All the listed privileges are required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_MANAGEMENT | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiAddAuxiliaryAccountsRequest
*/
func (a *ExternalAPIService) AddAuxiliaryAccounts(ctx context.Context, id string) ApiAddAuxiliaryAccountsRequest {
	return ApiAddAuxiliaryAccountsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []BulkItemResponseInfo
func (a *ExternalAPIService) AddAuxiliaryAccountsExecute(r ApiAddAuxiliaryAccountsRequest) ([]BulkItemResponseInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BulkItemResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.AddAuxiliaryAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains/{id}/action/add-auxiliary-accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuditEventsExtendedAttributesRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	ids *[]int64
}

// Audit Event IDs
func (r ApiAuditEventsExtendedAttributesRequest) Ids(ids []int64) ApiAuditEventsExtendedAttributesRequest {
	r.ids = &ids
	return r
}

func (r ApiAuditEventsExtendedAttributesRequest) Execute() ([]AuditEventAttributeInfo, *http.Response, error) {
	return r.ApiService.AuditEventsExtendedAttributesExecute(r)
}

/*
AuditEventsExtendedAttributes Get extended attributes of audit events

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAuditEventsExtendedAttributesRequest
*/
func (a *ExternalAPIService) AuditEventsExtendedAttributes(ctx context.Context) ApiAuditEventsExtendedAttributesRequest {
	return ApiAuditEventsExtendedAttributesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AuditEventAttributeInfo
func (a *ExternalAPIService) AuditEventsExtendedAttributesExecute(r ApiAuditEventsExtendedAttributesRequest) ([]AuditEventAttributeInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AuditEventAttributeInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.AuditEventsExtendedAttributes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/audit-events/extended-attributes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	{
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBindRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	body *ADDomainSpec
}

// Specification of untrusted domain.
func (r ApiBindRequest) Body(body ADDomainSpec) ApiBindRequest {
	r.body = &body
	return r
}

func (r ApiBindRequest) Execute() (*ADDomainBindInfo, *http.Response, error) {
	return r.ApiService.BindExecute(r)
}

/*
Bind Bind untrusted domain to the connection server.

All the listed privileges are required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_MANAGEMENT | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBindRequest
*/
func (a *ExternalAPIService) Bind(ctx context.Context) ApiBindRequest {
	return ApiBindRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ADDomainBindInfo
func (a *ExternalAPIService) BindExecute(r ApiBindRequest) (*ADDomainBindInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ADDomainBindInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.Bind")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains/action/bind"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkHoldUserOrGroupRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	body *[]string
}

// Set of AD user SIDs to put on hold.
func (r ApiBulkHoldUserOrGroupRequest) Body(body []string) ApiBulkHoldUserOrGroupRequest {
	r.body = &body
	return r
}

func (r ApiBulkHoldUserOrGroupRequest) Execute() ([]BulkItemResponseInfo, *http.Response, error) {
	return r.ApiService.BulkHoldUserOrGroupExecute(r)
}

/*
BulkHoldUserOrGroup Put users on hold.

All the listed privileges are required -  
| Privileges | Description |
| ---- | ---- |
| FORENSICS | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkHoldUserOrGroupRequest
*/
func (a *ExternalAPIService) BulkHoldUserOrGroup(ctx context.Context) ApiBulkHoldUserOrGroupRequest {
	return ApiBulkHoldUserOrGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BulkItemResponseInfo
func (a *ExternalAPIService) BulkHoldUserOrGroupExecute(r ApiBulkHoldUserOrGroupRequest) ([]BulkItemResponseInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BulkItemResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.BulkHoldUserOrGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-users-or-groups/action/hold"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkHoldUserOrGroupV2Request struct {
	ctx context.Context
	ApiService *ExternalAPIService
	body *[]string
}

// Set of AD user SIDs to put on hold.
func (r ApiBulkHoldUserOrGroupV2Request) Body(body []string) ApiBulkHoldUserOrGroupV2Request {
	r.body = &body
	return r
}

func (r ApiBulkHoldUserOrGroupV2Request) Execute() ([]HeldUserOrGroupResponseInfo, *http.Response, error) {
	return r.ApiService.BulkHoldUserOrGroupV2Execute(r)
}

/*
BulkHoldUserOrGroupV2 Put users on hold.

All the listed privileges are required -  
| Privileges | Description |
| ---- | ---- |
| FORENSICS | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkHoldUserOrGroupV2Request
*/
func (a *ExternalAPIService) BulkHoldUserOrGroupV2(ctx context.Context) ApiBulkHoldUserOrGroupV2Request {
	return ApiBulkHoldUserOrGroupV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []HeldUserOrGroupResponseInfo
func (a *ExternalAPIService) BulkHoldUserOrGroupV2Execute(r ApiBulkHoldUserOrGroupV2Request) ([]HeldUserOrGroupResponseInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HeldUserOrGroupResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.BulkHoldUserOrGroupV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v2/ad-users-or-groups/action/hold"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkReleaseHoldUserOrGroupRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	body *[]string
}

// Set of AD user SIDs to release from hold.
func (r ApiBulkReleaseHoldUserOrGroupRequest) Body(body []string) ApiBulkReleaseHoldUserOrGroupRequest {
	r.body = &body
	return r
}

func (r ApiBulkReleaseHoldUserOrGroupRequest) Execute() ([]BulkItemResponseInfo, *http.Response, error) {
	return r.ApiService.BulkReleaseHoldUserOrGroupExecute(r)
}

/*
BulkReleaseHoldUserOrGroup Release users from hold.

All the listed privileges are required -  
| Privileges | Description |
| ---- | ---- |
| FORENSICS | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkReleaseHoldUserOrGroupRequest
*/
func (a *ExternalAPIService) BulkReleaseHoldUserOrGroup(ctx context.Context) ApiBulkReleaseHoldUserOrGroupRequest {
	return ApiBulkReleaseHoldUserOrGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BulkItemResponseInfo
func (a *ExternalAPIService) BulkReleaseHoldUserOrGroupExecute(r ApiBulkReleaseHoldUserOrGroupRequest) ([]BulkItemResponseInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BulkItemResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.BulkReleaseHoldUserOrGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-users-or-groups/action/release-hold"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkReleaseHoldUserOrGroupV2Request struct {
	ctx context.Context
	ApiService *ExternalAPIService
	body *[]string
}

// Set of AD user SIDs to release from hold.
func (r ApiBulkReleaseHoldUserOrGroupV2Request) Body(body []string) ApiBulkReleaseHoldUserOrGroupV2Request {
	r.body = &body
	return r
}

func (r ApiBulkReleaseHoldUserOrGroupV2Request) Execute() ([]HeldUserOrGroupResponseInfo, *http.Response, error) {
	return r.ApiService.BulkReleaseHoldUserOrGroupV2Execute(r)
}

/*
BulkReleaseHoldUserOrGroupV2 Release users from hold.

All the listed privileges are required -  
| Privileges | Description |
| ---- | ---- |
| FORENSICS | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkReleaseHoldUserOrGroupV2Request
*/
func (a *ExternalAPIService) BulkReleaseHoldUserOrGroupV2(ctx context.Context) ApiBulkReleaseHoldUserOrGroupV2Request {
	return ApiBulkReleaseHoldUserOrGroupV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []HeldUserOrGroupResponseInfo
func (a *ExternalAPIService) BulkReleaseHoldUserOrGroupV2Execute(r ApiBulkReleaseHoldUserOrGroupV2Request) ([]HeldUserOrGroupResponseInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HeldUserOrGroupResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.BulkReleaseHoldUserOrGroupV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v2/ad-users-or-groups/action/release-hold"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangeUserPasswordRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	body *ADUserChangePasswordSpec
}

// AD user password object to be changed.
func (r ApiChangeUserPasswordRequest) Body(body ADUserChangePasswordSpec) ApiChangeUserPasswordRequest {
	r.body = &body
	return r
}

func (r ApiChangeUserPasswordRequest) Execute() (*ADUserInfo, *http.Response, error) {
	return r.ApiService.ChangeUserPasswordExecute(r)
}

/*
ChangeUserPassword Changes the password of AD User

All the listed privileges are required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_MANAGEMENT | Caller should have permission to this privilege to change the password of AD User.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChangeUserPasswordRequest
*/
func (a *ExternalAPIService) ChangeUserPassword(ctx context.Context) ApiChangeUserPasswordRequest {
	return ApiChangeUserPasswordRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ADUserInfo
func (a *ExternalAPIService) ChangeUserPasswordExecute(r ApiChangeUserPasswordRequest) (*ADUserInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ADUserInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ChangeUserPassword")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-users-or-groups/action/change-user-password"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiComputeSpaceRequirementsRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	body *DatastoreSpaceRequirementSpec
}

// Datastore space requirement to be computed.
func (r ApiComputeSpaceRequirementsRequest) Body(body DatastoreSpaceRequirementSpec) ApiComputeSpaceRequirementsRequest {
	r.body = &body
	return r
}

func (r ApiComputeSpaceRequirementsRequest) Execute() ([]DatastoreSpaceRequirementInfo, *http.Response, error) {
	return r.ApiService.ComputeSpaceRequirementsExecute(r)
}

/*
ComputeSpaceRequirements Computes the datastore space requirements for inventory resources.

All the listed privileges are required -  
| Privileges | Description |
| ---- | ---- |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| POOL_VIEW | Caller should have permission to this privilege, on the associated desktop or farm.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiComputeSpaceRequirementsRequest
*/
func (a *ExternalAPIService) ComputeSpaceRequirements(ctx context.Context) ApiComputeSpaceRequirementsRequest {
	return ApiComputeSpaceRequirementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DatastoreSpaceRequirementInfo
func (a *ExternalAPIService) ComputeSpaceRequirementsExecute(r ApiComputeSpaceRequirementsRequest) ([]DatastoreSpaceRequirementInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DatastoreSpaceRequirementInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ComputeSpaceRequirements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/datastores/action/compute-requirements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAuxiliaryAccountsRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	id string
	body *ADDomainAuxiliaryAccountDeleteSpec
}

// Auxiliary accounts to delete.
func (r ApiDeleteAuxiliaryAccountsRequest) Body(body ADDomainAuxiliaryAccountDeleteSpec) ApiDeleteAuxiliaryAccountsRequest {
	r.body = &body
	return r
}

func (r ApiDeleteAuxiliaryAccountsRequest) Execute() ([]BulkItemResponseInfo, *http.Response, error) {
	return r.ApiService.DeleteAuxiliaryAccountsExecute(r)
}

/*
DeleteAuxiliaryAccounts Specification to delete auxiliary accounts from the untrusted domain

All the listed privileges are required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_MANAGEMENT | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiDeleteAuxiliaryAccountsRequest
*/
func (a *ExternalAPIService) DeleteAuxiliaryAccounts(ctx context.Context, id string) ApiDeleteAuxiliaryAccountsRequest {
	return ApiDeleteAuxiliaryAccountsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []BulkItemResponseInfo
func (a *ExternalAPIService) DeleteAuxiliaryAccountsExecute(r ApiDeleteAuxiliaryAccountsRequest) ([]BulkItemResponseInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BulkItemResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.DeleteAuxiliaryAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains/{id}/action/delete-auxiliary-accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetADContainerRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	id string
	rdn string
}

func (r ApiGetADContainerRequest) Execute() (*ADContainerInfo, *http.Response, error) {
	return r.ApiService.GetADContainerExecute(r)
}

/*
GetADContainer Gets the AD container for specified domain.

At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
POOL_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id AD Domain SID
 @param rdn rdn of AD container in Base64URL encoded format.
 @return ApiGetADContainerRequest
*/
func (a *ExternalAPIService) GetADContainer(ctx context.Context, id string, rdn string) ApiGetADContainerRequest {
	return ApiGetADContainerRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		rdn: rdn,
	}
}

// Execute executes the request
//  @return ADContainerInfo
func (a *ExternalAPIService) GetADContainerExecute(r ApiGetADContainerRequest) (*ADContainerInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ADContainerInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.GetADContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains/{id}/ad-containers/{rdn}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rdn"+"}", url.PathEscape(parameterValueToString(r.rdn, "rdn")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetADUserOrGroupInfoRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	id string
}

func (r ApiGetADUserOrGroupInfoRequest) Execute() (*ADUserOrGroupInfo, *http.Response, error) {
	return r.ApiService.GetADUserOrGroupInfoExecute(r)
}

/*
GetADUserOrGroupInfo Get information related to AD User or Group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiGetADUserOrGroupInfoRequest
*/
func (a *ExternalAPIService) GetADUserOrGroupInfo(ctx context.Context, id string) ApiGetADUserOrGroupInfoRequest {
	return ApiGetADUserOrGroupInfoRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ADUserOrGroupInfo
func (a *ExternalAPIService) GetADUserOrGroupInfoExecute(r ApiGetADUserOrGroupInfoRequest) (*ADUserOrGroupInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ADUserOrGroupInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.GetADUserOrGroupInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-users-or-groups/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDefaultADContainerRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	id string
}

func (r ApiGetDefaultADContainerRequest) Execute() (*ADContainerInfo, *http.Response, error) {
	return r.ApiService.GetDefaultADContainerExecute(r)
}

/*
GetDefaultADContainer Get default AD container for specified domain.

At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
POOL_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id AD Domain SID
 @return ApiGetDefaultADContainerRequest
*/
func (a *ExternalAPIService) GetDefaultADContainer(ctx context.Context, id string) ApiGetDefaultADContainerRequest {
	return ApiGetDefaultADContainerRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ADContainerInfo
func (a *ExternalAPIService) GetDefaultADContainerExecute(r ApiGetDefaultADContainerRequest) (*ADContainerInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ADContainerInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.GetDefaultADContainer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains/{id}/ad-containers/default"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListADContainersRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	id string
	containerName *string
	rdn *string
	subTreeSearch *bool
}

// AD container name in Base64URL encoded format
func (r ApiListADContainersRequest) ContainerName(containerName string) ApiListADContainersRequest {
	r.containerName = &containerName
	return r
}

// rdn of AD container in Base64URL encoded format
func (r ApiListADContainersRequest) Rdn(rdn string) ApiListADContainersRequest {
	r.rdn = &rdn
	return r
}

// true to search subtree. Subtree search is only supported for rdn.
func (r ApiListADContainersRequest) SubTreeSearch(subTreeSearch bool) ApiListADContainersRequest {
	r.subTreeSearch = &subTreeSearch
	return r
}

func (r ApiListADContainersRequest) Execute() ([]ADContainerInfo, *http.Response, error) {
	return r.ApiService.ListADContainersExecute(r)
}

/*
ListADContainers List active directory containers for a specific domain.

At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
POOL_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id AD domain SID
 @return ApiListADContainersRequest
*/
func (a *ExternalAPIService) ListADContainers(ctx context.Context, id string) ApiListADContainersRequest {
	return ApiListADContainersRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []ADContainerInfo
func (a *ExternalAPIService) ListADContainersExecute(r ApiListADContainersRequest) ([]ADContainerInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ADContainerInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListADContainers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains/{id}/ad-containers"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.containerName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "container_name", r.containerName, "")
	}
	if r.rdn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rdn", r.rdn, "")
	}
	if r.subTreeSearch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sub_tree_search", r.subTreeSearch, "")
	} else {
		var defaultValue bool = false
		r.subTreeSearch = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListADDomainsRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
}

func (r ApiListADDomainsRequest) Execute() ([]ADDomainInfo, *http.Response, error) {
	return r.ApiService.ListADDomainsExecute(r)
}

/*
ListADDomains Lists information related to AD Domains of the environment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListADDomainsRequest
*/
func (a *ExternalAPIService) ListADDomains(ctx context.Context) ApiListADDomainsRequest {
	return ApiListADDomainsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ADDomainInfo
func (a *ExternalAPIService) ListADDomainsExecute(r ApiListADDomainsRequest) ([]ADDomainInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ADDomainInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListADDomains")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListADDomainsV2Request struct {
	ctx context.Context
	ApiService *ExternalAPIService
}

func (r ApiListADDomainsV2Request) Execute() ([]ADDomainInfoV2, *http.Response, error) {
	return r.ApiService.ListADDomainsV2Execute(r)
}

/*
ListADDomainsV2 Lists information related to AD Domains of the environment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListADDomainsV2Request
*/
func (a *ExternalAPIService) ListADDomainsV2(ctx context.Context) ApiListADDomainsV2Request {
	return ApiListADDomainsV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ADDomainInfoV2
func (a *ExternalAPIService) ListADDomainsV2Execute(r ApiListADDomainsV2Request) ([]ADDomainInfoV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ADDomainInfoV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListADDomainsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v2/ad-domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListADDomainsV3Request struct {
	ctx context.Context
	ApiService *ExternalAPIService
}

func (r ApiListADDomainsV3Request) Execute() ([]ADDomainInfoV3, *http.Response, error) {
	return r.ApiService.ListADDomainsV3Execute(r)
}

/*
ListADDomainsV3 Lists information related to AD Domains of the environment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListADDomainsV3Request
*/
func (a *ExternalAPIService) ListADDomainsV3(ctx context.Context) ApiListADDomainsV3Request {
	return ApiListADDomainsV3Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ADDomainInfoV3
func (a *ExternalAPIService) ListADDomainsV3Execute(r ApiListADDomainsV3Request) ([]ADDomainInfoV3, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ADDomainInfoV3
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListADDomainsV3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v3/ad-domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListADUserOrGroupSummaryRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	filter *string
	groupOnly *string
	page *int32
	size *int32
}

// filter expression built using fields with &lt;b&gt;&#39;supported filters&#39;&lt;/b&gt; as described in output &lt;b&gt;model&lt;/b&gt; schema of this API.
func (r ApiListADUserOrGroupSummaryRequest) Filter(filter string) ApiListADUserOrGroupSummaryRequest {
	r.filter = &filter
	return r
}

// Presence of this query param indicates to filter only groups or only users.   If passed as \&quot;true\&quot;, then only groups are returned.  If passed as \&quot;false\&quot;, then only users are returned.  If not passed passed at all, then both types are returned.
func (r ApiListADUserOrGroupSummaryRequest) GroupOnly(groupOnly string) ApiListADUserOrGroupSummaryRequest {
	r.groupOnly = &groupOnly
	return r
}

// page, if passed should be &gt; 0.
func (r ApiListADUserOrGroupSummaryRequest) Page(page int32) ApiListADUserOrGroupSummaryRequest {
	r.page = &page
	return r
}

// size, if passed should be &gt; 0.
func (r ApiListADUserOrGroupSummaryRequest) Size(size int32) ApiListADUserOrGroupSummaryRequest {
	r.size = &size
	return r
}

func (r ApiListADUserOrGroupSummaryRequest) Execute() ([]ADUserOrGroupSummary, *http.Response, error) {
	return r.ApiService.ListADUserOrGroupSummaryExecute(r)
}

/*
ListADUserOrGroupSummary Lists AD users or groups information.

This API supports <b>Pagination</b> and <b>Filters.</b><br/>For full information on using Filters, refer to 'Horizon Server REST Pagination and Filter Guide' of 'VMware Horizon Server API' in code.vmware.com

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListADUserOrGroupSummaryRequest
*/
func (a *ExternalAPIService) ListADUserOrGroupSummary(ctx context.Context) ApiListADUserOrGroupSummaryRequest {
	return ApiListADUserOrGroupSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ADUserOrGroupSummary
func (a *ExternalAPIService) ListADUserOrGroupSummaryExecute(r ApiListADUserOrGroupSummaryRequest) ([]ADUserOrGroupSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ADUserOrGroupSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListADUserOrGroupSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-users-or-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.groupOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group_only", r.groupOnly, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAuditEventsRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	filter *string
	page *int32
	size *int32
}

// filter expression built using fields with &lt;b&gt;&#39;supported filters&#39;&lt;/b&gt; as described in output &lt;b&gt;model&lt;/b&gt; schema of this API.
func (r ApiListAuditEventsRequest) Filter(filter string) ApiListAuditEventsRequest {
	r.filter = &filter
	return r
}

// page, if passed should be &gt; 0.
func (r ApiListAuditEventsRequest) Page(page int32) ApiListAuditEventsRequest {
	r.page = &page
	return r
}

// size, if passed should be &gt; 0.
func (r ApiListAuditEventsRequest) Size(size int32) ApiListAuditEventsRequest {
	r.size = &size
	return r
}

func (r ApiListAuditEventsRequest) Execute() ([]AuditEventSummary, *http.Response, error) {
	return r.ApiService.ListAuditEventsExecute(r)
}

/*
ListAuditEvents Lists the audit events.

This API supports <b>Pagination</b>.<br/>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAuditEventsRequest
*/
func (a *ExternalAPIService) ListAuditEvents(ctx context.Context) ApiListAuditEventsRequest {
	return ApiListAuditEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AuditEventSummary
func (a *ExternalAPIService) ListAuditEventsExecute(r ApiListAuditEventsRequest) ([]AuditEventSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AuditEventSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListAuditEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/audit-events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBaseSnapshotsRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	baseVmId *string
	vcenterId *string
}

// VM ID
func (r ApiListBaseSnapshotsRequest) BaseVmId(baseVmId string) ApiListBaseSnapshotsRequest {
	r.baseVmId = &baseVmId
	return r
}

// Virtual Center ID
func (r ApiListBaseSnapshotsRequest) VcenterId(vcenterId string) ApiListBaseSnapshotsRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListBaseSnapshotsRequest) Execute() ([]BaseSnapshotInfo, *http.Response, error) {
	return r.ApiService.ListBaseSnapshotsExecute(r)
}

/*
ListBaseSnapshots Lists all the VM snapshots from the vCenter for a given VM.

At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBaseSnapshotsRequest
*/
func (a *ExternalAPIService) ListBaseSnapshots(ctx context.Context) ApiListBaseSnapshotsRequest {
	return ApiListBaseSnapshotsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BaseSnapshotInfo
func (a *ExternalAPIService) ListBaseSnapshotsExecute(r ApiListBaseSnapshotsRequest) ([]BaseSnapshotInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BaseSnapshotInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListBaseSnapshots")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/base-snapshots"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.baseVmId == nil {
		return localVarReturnValue, nil, reportError("baseVmId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "base_vm_id", r.baseVmId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBaseSnapshotsV2Request struct {
	ctx context.Context
	ApiService *ExternalAPIService
	baseVmId *string
	vcenterId *string
}

// VM ID
func (r ApiListBaseSnapshotsV2Request) BaseVmId(baseVmId string) ApiListBaseSnapshotsV2Request {
	r.baseVmId = &baseVmId
	return r
}

// Virtual Center ID
func (r ApiListBaseSnapshotsV2Request) VcenterId(vcenterId string) ApiListBaseSnapshotsV2Request {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListBaseSnapshotsV2Request) Execute() ([]BaseSnapshotInfoV2, *http.Response, error) {
	return r.ApiService.ListBaseSnapshotsV2Execute(r)
}

/*
ListBaseSnapshotsV2 Lists all the VM snapshots from the vCenter for a given VM.

At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBaseSnapshotsV2Request
*/
func (a *ExternalAPIService) ListBaseSnapshotsV2(ctx context.Context) ApiListBaseSnapshotsV2Request {
	return ApiListBaseSnapshotsV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BaseSnapshotInfoV2
func (a *ExternalAPIService) ListBaseSnapshotsV2Execute(r ApiListBaseSnapshotsV2Request) ([]BaseSnapshotInfoV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BaseSnapshotInfoV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListBaseSnapshotsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v2/base-snapshots"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.baseVmId == nil {
		return localVarReturnValue, nil, reportError("baseVmId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "base_vm_id", r.baseVmId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBaseVMsRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	vcenterId *string
	datacenterId *string
	filterIncompatibleVms *bool
}

// Virtual Center ID
func (r ApiListBaseVMsRequest) VcenterId(vcenterId string) ApiListBaseVMsRequest {
	r.vcenterId = &vcenterId
	return r
}

// Datacenter ID
func (r ApiListBaseVMsRequest) DatacenterId(datacenterId string) ApiListBaseVMsRequest {
	r.datacenterId = &datacenterId
	return r
}

// Whether to filter out incompatible VMs
func (r ApiListBaseVMsRequest) FilterIncompatibleVms(filterIncompatibleVms bool) ApiListBaseVMsRequest {
	r.filterIncompatibleVms = &filterIncompatibleVms
	return r
}

func (r ApiListBaseVMsRequest) Execute() ([]BaseVMInfo, *http.Response, error) {
	return r.ApiService.ListBaseVMsExecute(r)
}

/*
ListBaseVMs Lists all the VMs from a vCenter or a datacenter in that vCenter which may be suitable as snapshots for instant clone desktop pool or farm creation.

At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBaseVMsRequest
*/
func (a *ExternalAPIService) ListBaseVMs(ctx context.Context) ApiListBaseVMsRequest {
	return ApiListBaseVMsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BaseVMInfo
func (a *ExternalAPIService) ListBaseVMsExecute(r ApiListBaseVMsRequest) ([]BaseVMInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BaseVMInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListBaseVMs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/base-vms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	if r.datacenterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "datacenter_id", r.datacenterId, "")
	}
	if r.filterIncompatibleVms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter_incompatible_vms", r.filterIncompatibleVms, "")
	} else {
		var defaultValue bool = false
		r.filterIncompatibleVms = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBaseVMsV2Request struct {
	ctx context.Context
	ApiService *ExternalAPIService
	vcenterId *string
	datacenterId *string
	filterIncompatibleVms *bool
}

// Virtual Center ID
func (r ApiListBaseVMsV2Request) VcenterId(vcenterId string) ApiListBaseVMsV2Request {
	r.vcenterId = &vcenterId
	return r
}

// Datacenter ID
func (r ApiListBaseVMsV2Request) DatacenterId(datacenterId string) ApiListBaseVMsV2Request {
	r.datacenterId = &datacenterId
	return r
}

// Whether to filter out incompatible VMs
func (r ApiListBaseVMsV2Request) FilterIncompatibleVms(filterIncompatibleVms bool) ApiListBaseVMsV2Request {
	r.filterIncompatibleVms = &filterIncompatibleVms
	return r
}

func (r ApiListBaseVMsV2Request) Execute() ([]BaseVMInfoV2, *http.Response, error) {
	return r.ApiService.ListBaseVMsV2Execute(r)
}

/*
ListBaseVMsV2 Lists all the VMs from a vCenter or a datacenter in that vCenter which may be suitable as snapshots for instant clone desktop pool or farm creation.

At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBaseVMsV2Request
*/
func (a *ExternalAPIService) ListBaseVMsV2(ctx context.Context) ApiListBaseVMsV2Request {
	return ApiListBaseVMsV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BaseVMInfoV2
func (a *ExternalAPIService) ListBaseVMsV2Execute(r ApiListBaseVMsV2Request) ([]BaseVMInfoV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BaseVMInfoV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListBaseVMsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v2/base-vms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	if r.datacenterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "datacenter_id", r.datacenterId, "")
	}
	if r.filterIncompatibleVms != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter_incompatible_vms", r.filterIncompatibleVms, "")
	} else {
		var defaultValue bool = false
		r.filterIncompatibleVms = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCustomizationSpecsRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	vcenterId *string
}

// Virtual Center ID
func (r ApiListCustomizationSpecsRequest) VcenterId(vcenterId string) ApiListCustomizationSpecsRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListCustomizationSpecsRequest) Execute() ([]CustomizationSpecInfo, *http.Response, error) {
	return r.ApiService.ListCustomizationSpecsExecute(r)
}

/*
ListCustomizationSpecs Lists all the customization specifications from the vCenter.

At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCustomizationSpecsRequest
*/
func (a *ExternalAPIService) ListCustomizationSpecs(ctx context.Context) ApiListCustomizationSpecsRequest {
	return ApiListCustomizationSpecsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CustomizationSpecInfo
func (a *ExternalAPIService) ListCustomizationSpecsExecute(r ApiListCustomizationSpecsRequest) ([]CustomizationSpecInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CustomizationSpecInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListCustomizationSpecs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/customization-specifications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDatacentersRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	vcenterId *string
}

// Virtual Center ID
func (r ApiListDatacentersRequest) VcenterId(vcenterId string) ApiListDatacentersRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListDatacentersRequest) Execute() ([]DatacenterInfo, *http.Response, error) {
	return r.ApiService.ListDatacentersExecute(r)
}

/*
ListDatacenters Lists all the datacenters of a vCenter.

All the listed privileges are required -  
| Privileges | Description |
| ---- | ---- |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDatacentersRequest
*/
func (a *ExternalAPIService) ListDatacenters(ctx context.Context) ApiListDatacentersRequest {
	return ApiListDatacentersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DatacenterInfo
func (a *ExternalAPIService) ListDatacentersExecute(r ApiListDatacentersRequest) ([]DatacenterInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DatacenterInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListDatacenters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/datacenters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDatastoreClustersRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	hostOrClusterId *string
	vcenterId *string
}

// Host or Cluster ID
func (r ApiListDatastoreClustersRequest) HostOrClusterId(hostOrClusterId string) ApiListDatastoreClustersRequest {
	r.hostOrClusterId = &hostOrClusterId
	return r
}

// Virtual Center ID
func (r ApiListDatastoreClustersRequest) VcenterId(vcenterId string) ApiListDatastoreClustersRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListDatastoreClustersRequest) Execute() ([]DatastoreClusterInfo, *http.Response, error) {
	return r.ApiService.ListDatastoreClustersExecute(r)
}

/*
ListDatastoreClusters Lists all the datastore clusters from the vCenter for the given host or cluster.

At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDatastoreClustersRequest
*/
func (a *ExternalAPIService) ListDatastoreClusters(ctx context.Context) ApiListDatastoreClustersRequest {
	return ApiListDatastoreClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DatastoreClusterInfo
func (a *ExternalAPIService) ListDatastoreClustersExecute(r ApiListDatastoreClustersRequest) ([]DatastoreClusterInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DatastoreClusterInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListDatastoreClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/datastore-clusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hostOrClusterId == nil {
		return localVarReturnValue, nil, reportError("hostOrClusterId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "host_or_cluster_id", r.hostOrClusterId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDatastorePathsRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	datastoreId *string
	vcenterId *string
}

// Datastore ID
func (r ApiListDatastorePathsRequest) DatastoreId(datastoreId string) ApiListDatastorePathsRequest {
	r.datastoreId = &datastoreId
	return r
}

// Virtual Center ID
func (r ApiListDatastorePathsRequest) VcenterId(vcenterId string) ApiListDatastorePathsRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListDatastorePathsRequest) Execute() ([]DatastorePathInfo, *http.Response, error) {
	return r.ApiService.ListDatastorePathsExecute(r)
}

/*
ListDatastorePaths Lists all the folder paths within a Datastore from vCenter.

At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDatastorePathsRequest
*/
func (a *ExternalAPIService) ListDatastorePaths(ctx context.Context) ApiListDatastorePathsRequest {
	return ApiListDatastorePathsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DatastorePathInfo
func (a *ExternalAPIService) ListDatastorePathsExecute(r ApiListDatastorePathsRequest) ([]DatastorePathInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DatastorePathInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListDatastorePaths")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/datastore-paths"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.datastoreId == nil {
		return localVarReturnValue, nil, reportError("datastoreId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "datastore_id", r.datastoreId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDomainsRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
}

func (r ApiListDomainsRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.ListDomainsExecute(r)
}

/*
ListDomains Returns a map of domain NETBIOS name and dns name for domains which are configured on connection server.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDomainsRequest
*/
func (a *ExternalAPIService) ListDomains(ctx context.Context) ApiListDomainsRequest {
	return ApiListDomainsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]string
func (a *ExternalAPIService) ListDomainsExecute(r ApiListDomainsRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListDomains")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/domains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListHeldUsersOrGroupsRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
}

func (r ApiListHeldUsersOrGroupsRequest) Execute() ([]HeldUserOrGroupInfo, *http.Response, error) {
	return r.ApiService.ListHeldUsersOrGroupsExecute(r)
}

/*
ListHeldUsersOrGroups List information related to Held Users.

All the listed privileges are required -  
| Privileges | Description |
| ---- | ---- |
| FORENSICS | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListHeldUsersOrGroupsRequest
*/
func (a *ExternalAPIService) ListHeldUsersOrGroups(ctx context.Context) ApiListHeldUsersOrGroupsRequest {
	return ApiListHeldUsersOrGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []HeldUserOrGroupInfo
func (a *ExternalAPIService) ListHeldUsersOrGroupsExecute(r ApiListHeldUsersOrGroupsRequest) ([]HeldUserOrGroupInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HeldUserOrGroupInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListHeldUsersOrGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-users-or-groups/held-users-or-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListHostsOrClustersRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	datacenterId *string
	vcenterId *string
}

// Datacenter ID
func (r ApiListHostsOrClustersRequest) DatacenterId(datacenterId string) ApiListHostsOrClustersRequest {
	r.datacenterId = &datacenterId
	return r
}

// Virtual Center ID
func (r ApiListHostsOrClustersRequest) VcenterId(vcenterId string) ApiListHostsOrClustersRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListHostsOrClustersRequest) Execute() ([]HostOrClusterInfo, *http.Response, error) {
	return r.ApiService.ListHostsOrClustersExecute(r)
}

/*
ListHostsOrClusters Lists all the hosts or clusters of the datacenter.

At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListHostsOrClustersRequest
*/
func (a *ExternalAPIService) ListHostsOrClusters(ctx context.Context) ApiListHostsOrClustersRequest {
	return ApiListHostsOrClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []HostOrClusterInfo
func (a *ExternalAPIService) ListHostsOrClustersExecute(r ApiListHostsOrClustersRequest) ([]HostOrClusterInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HostOrClusterInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListHostsOrClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/hosts-or-clusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.datacenterId == nil {
		return localVarReturnValue, nil, reportError("datacenterId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "datacenter_id", r.datacenterId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListNetworkInterfaceCardsRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	vcenterId *string
	baseSnapshotId *string
	baseVmId *string
	vmTemplateId *string
}

// Virtual Center ID
func (r ApiListNetworkInterfaceCardsRequest) VcenterId(vcenterId string) ApiListNetworkInterfaceCardsRequest {
	r.vcenterId = &vcenterId
	return r
}

// Base Snapshot ID
func (r ApiListNetworkInterfaceCardsRequest) BaseSnapshotId(baseSnapshotId string) ApiListNetworkInterfaceCardsRequest {
	r.baseSnapshotId = &baseSnapshotId
	return r
}

// Base VM ID
func (r ApiListNetworkInterfaceCardsRequest) BaseVmId(baseVmId string) ApiListNetworkInterfaceCardsRequest {
	r.baseVmId = &baseVmId
	return r
}

// VM Template ID
func (r ApiListNetworkInterfaceCardsRequest) VmTemplateId(vmTemplateId string) ApiListNetworkInterfaceCardsRequest {
	r.vmTemplateId = &vmTemplateId
	return r
}

func (r ApiListNetworkInterfaceCardsRequest) Execute() ([]NetworkInterfaceCardInfo, *http.Response, error) {
	return r.ApiService.ListNetworkInterfaceCardsExecute(r)
}

/*
ListNetworkInterfaceCards Returns a list of network interface cards (NICs) suitable for configuration on a desktop pool/farm.

If the base VM and snapshot are specified, then the NICs  present on the given snapshot are listed.<br/> If the template is specified then the NICs present on the given template are listed.<br/> If only base VM is specified then the NICs present on the given base VM are listed.<br/>At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListNetworkInterfaceCardsRequest
*/
func (a *ExternalAPIService) ListNetworkInterfaceCards(ctx context.Context) ApiListNetworkInterfaceCardsRequest {
	return ApiListNetworkInterfaceCardsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NetworkInterfaceCardInfo
func (a *ExternalAPIService) ListNetworkInterfaceCardsExecute(r ApiListNetworkInterfaceCardsRequest) ([]NetworkInterfaceCardInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NetworkInterfaceCardInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListNetworkInterfaceCards")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/network-interface-cards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	if r.baseSnapshotId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_snapshot_id", r.baseSnapshotId, "")
	}
	if r.baseVmId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_vm_id", r.baseVmId, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	if r.vmTemplateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vm_template_id", r.vmTemplateId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListNetworkInterfaceCardsV2Request struct {
	ctx context.Context
	ApiService *ExternalAPIService
	vcenterId *string
	baseSnapshotId *string
	baseVmId *string
	vmTemplateId *string
}

// Virtual Center ID
func (r ApiListNetworkInterfaceCardsV2Request) VcenterId(vcenterId string) ApiListNetworkInterfaceCardsV2Request {
	r.vcenterId = &vcenterId
	return r
}

// Base Snapshot ID
func (r ApiListNetworkInterfaceCardsV2Request) BaseSnapshotId(baseSnapshotId string) ApiListNetworkInterfaceCardsV2Request {
	r.baseSnapshotId = &baseSnapshotId
	return r
}

// Base VM ID
func (r ApiListNetworkInterfaceCardsV2Request) BaseVmId(baseVmId string) ApiListNetworkInterfaceCardsV2Request {
	r.baseVmId = &baseVmId
	return r
}

// VM Template ID
func (r ApiListNetworkInterfaceCardsV2Request) VmTemplateId(vmTemplateId string) ApiListNetworkInterfaceCardsV2Request {
	r.vmTemplateId = &vmTemplateId
	return r
}

func (r ApiListNetworkInterfaceCardsV2Request) Execute() ([]NetworkInterfaceCardInfoV2, *http.Response, error) {
	return r.ApiService.ListNetworkInterfaceCardsV2Execute(r)
}

/*
ListNetworkInterfaceCardsV2 Returns a list of network interface cards (NICs) suitable for configuration on a desktop pool/farm.

If the base VM and snapshot are specified, then the NICs  present on the given snapshot are listed.<br/> If the template is specified then the NICs present on the given template are listed.<br/> If only base VM is specified then the NICs present on the given base VM are listed.<br/>At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListNetworkInterfaceCardsV2Request
*/
func (a *ExternalAPIService) ListNetworkInterfaceCardsV2(ctx context.Context) ApiListNetworkInterfaceCardsV2Request {
	return ApiListNetworkInterfaceCardsV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NetworkInterfaceCardInfoV2
func (a *ExternalAPIService) ListNetworkInterfaceCardsV2Execute(r ApiListNetworkInterfaceCardsV2Request) ([]NetworkInterfaceCardInfoV2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NetworkInterfaceCardInfoV2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListNetworkInterfaceCardsV2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v2/network-interface-cards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	if r.baseSnapshotId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_snapshot_id", r.baseSnapshotId, "")
	}
	if r.baseVmId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_vm_id", r.baseVmId, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	if r.vmTemplateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vm_template_id", r.vmTemplateId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListNetworkLabelsRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	hostOrClusterId *string
	vcenterId *string
	networkType *string
}

// Host or Cluster ID
func (r ApiListNetworkLabelsRequest) HostOrClusterId(hostOrClusterId string) ApiListNetworkLabelsRequest {
	r.hostOrClusterId = &hostOrClusterId
	return r
}

// Virtual Center ID
func (r ApiListNetworkLabelsRequest) VcenterId(vcenterId string) ApiListNetworkLabelsRequest {
	r.vcenterId = &vcenterId
	return r
}

// Network Type * NETWORK: Standard network. * OPAQUE_NETWORK: Opaque network. * DISTRUBUTED_VIRTUAL_PORT_GROUP: DVS Port group.
func (r ApiListNetworkLabelsRequest) NetworkType(networkType string) ApiListNetworkLabelsRequest {
	r.networkType = &networkType
	return r
}

func (r ApiListNetworkLabelsRequest) Execute() ([]NetworkLabelInfo, *http.Response, error) {
	return r.ApiService.ListNetworkLabelsExecute(r)
}

/*
ListNetworkLabels Retrieves all network labels on the given host or cluster

API retrieves by filtering on the network type (if specified) that may be suitable for configuration with a desktop pool/farm's network interface card.<br/>At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListNetworkLabelsRequest
*/
func (a *ExternalAPIService) ListNetworkLabels(ctx context.Context) ApiListNetworkLabelsRequest {
	return ApiListNetworkLabelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NetworkLabelInfo
func (a *ExternalAPIService) ListNetworkLabelsExecute(r ApiListNetworkLabelsRequest) ([]NetworkLabelInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NetworkLabelInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListNetworkLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/network-labels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hostOrClusterId == nil {
		return localVarReturnValue, nil, reportError("hostOrClusterId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "host_or_cluster_id", r.hostOrClusterId, "")
	if r.networkType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network_type", r.networkType, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListResourcePoolsRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	hostOrClusterId *string
	vcenterId *string
}

// Host or Cluster ID
func (r ApiListResourcePoolsRequest) HostOrClusterId(hostOrClusterId string) ApiListResourcePoolsRequest {
	r.hostOrClusterId = &hostOrClusterId
	return r
}

// Virtual Center ID
func (r ApiListResourcePoolsRequest) VcenterId(vcenterId string) ApiListResourcePoolsRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListResourcePoolsRequest) Execute() ([]ResourcePoolInfo, *http.Response, error) {
	return r.ApiService.ListResourcePoolsExecute(r)
}

/*
ListResourcePools Lists all the resource pools from the vCenter for the given host or cluster.

At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListResourcePoolsRequest
*/
func (a *ExternalAPIService) ListResourcePools(ctx context.Context) ApiListResourcePoolsRequest {
	return ApiListResourcePoolsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ResourcePoolInfo
func (a *ExternalAPIService) ListResourcePoolsExecute(r ApiListResourcePoolsRequest) ([]ResourcePoolInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ResourcePoolInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListResourcePools")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/resource-pools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hostOrClusterId == nil {
		return localVarReturnValue, nil, reportError("hostOrClusterId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "host_or_cluster_id", r.hostOrClusterId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVMFoldersRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	datacenterId *string
	vcenterId *string
}

// Datacenter ID
func (r ApiListVMFoldersRequest) DatacenterId(datacenterId string) ApiListVMFoldersRequest {
	r.datacenterId = &datacenterId
	return r
}

// Virtual Center ID
func (r ApiListVMFoldersRequest) VcenterId(vcenterId string) ApiListVMFoldersRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListVMFoldersRequest) Execute() ([]VMFolderInfo, *http.Response, error) {
	return r.ApiService.ListVMFoldersExecute(r)
}

/*
ListVMFolders Lists all the VM folders from the vCenter for the given datacenter.

At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListVMFoldersRequest
*/
func (a *ExternalAPIService) ListVMFolders(ctx context.Context) ApiListVMFoldersRequest {
	return ApiListVMFoldersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VMFolderInfo
func (a *ExternalAPIService) ListVMFoldersExecute(r ApiListVMFoldersRequest) ([]VMFolderInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VMFolderInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListVMFolders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/vm-folders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.datacenterId == nil {
		return localVarReturnValue, nil, reportError("datacenterId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "datacenter_id", r.datacenterId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVMTemplatesRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	vcenterId *string
	datacenterId *string
}

// Virtual Center ID
func (r ApiListVMTemplatesRequest) VcenterId(vcenterId string) ApiListVMTemplatesRequest {
	r.vcenterId = &vcenterId
	return r
}

// Datacenter ID
func (r ApiListVMTemplatesRequest) DatacenterId(datacenterId string) ApiListVMTemplatesRequest {
	r.datacenterId = &datacenterId
	return r
}

func (r ApiListVMTemplatesRequest) Execute() ([]VMTemplateInfo, *http.Response, error) {
	return r.ApiService.ListVMTemplatesExecute(r)
}

/*
ListVMTemplates Lists all the VM templates from a vCenter or a datacenter for the given vCenter which may be suitable for full clone desktop pool creation.

At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListVMTemplatesRequest
*/
func (a *ExternalAPIService) ListVMTemplates(ctx context.Context) ApiListVMTemplatesRequest {
	return ApiListVMTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VMTemplateInfo
func (a *ExternalAPIService) ListVMTemplatesExecute(r ApiListVMTemplatesRequest) ([]VMTemplateInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VMTemplateInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListVMTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/vm-templates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	if r.datacenterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "datacenter_id", r.datacenterId, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVirtualMachinesRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	vcenterId *string
}

// Virtual Center ID
func (r ApiListVirtualMachinesRequest) VcenterId(vcenterId string) ApiListVirtualMachinesRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListVirtualMachinesRequest) Execute() ([]VirtualMachineInfo, *http.Response, error) {
	return r.ApiService.ListVirtualMachinesExecute(r)
}

/*
ListVirtualMachines Lists all the VMs from a vCenter.

At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListVirtualMachinesRequest
*/
func (a *ExternalAPIService) ListVirtualMachines(ctx context.Context) ApiListVirtualMachinesRequest {
	return ApiListVirtualMachinesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VirtualMachineInfo
func (a *ExternalAPIService) ListVirtualMachinesExecute(r ApiListVirtualMachinesRequest) ([]VirtualMachineInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VirtualMachineInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ListVirtualMachines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/virtual-machines"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListdatastoresRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	hostOrClusterId *string
	vcenterId *string
}

// Host or Cluster ID
func (r ApiListdatastoresRequest) HostOrClusterId(hostOrClusterId string) ApiListdatastoresRequest {
	r.hostOrClusterId = &hostOrClusterId
	return r
}

// Virtual Center ID
func (r ApiListdatastoresRequest) VcenterId(vcenterId string) ApiListdatastoresRequest {
	r.vcenterId = &vcenterId
	return r
}

func (r ApiListdatastoresRequest) Execute() ([]DatastoreInfo, *http.Response, error) {
	return r.ApiService.ListdatastoresExecute(r)
}

/*
Listdatastores Lists all the datastores from the vCenter for the given host or cluster.

At least one of the listed privileges is required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |
| VC_CONFIG_VIEW | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListdatastoresRequest
*/
func (a *ExternalAPIService) Listdatastores(ctx context.Context) ApiListdatastoresRequest {
	return ApiListdatastoresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DatastoreInfo
func (a *ExternalAPIService) ListdatastoresExecute(r ApiListdatastoresRequest) ([]DatastoreInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DatastoreInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.Listdatastores")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/datastores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hostOrClusterId == nil {
		return localVarReturnValue, nil, reportError("hostOrClusterId is required and must be specified")
	}
	if r.vcenterId == nil {
		return localVarReturnValue, nil, reportError("vcenterId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "host_or_cluster_id", r.hostOrClusterId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "vcenter_id", r.vcenterId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnbindRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	id string
}

func (r ApiUnbindRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnbindExecute(r)
}

/*
Unbind Unbind untrusted domain from the connection server.

All the listed privileges are required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_MANAGEMENT | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiUnbindRequest
*/
func (a *ExternalAPIService) Unbind(ctx context.Context, id string) ApiUnbindRequest {
	return ApiUnbindRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExternalAPIService) UnbindExecute(r ApiUnbindRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.Unbind")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains/{id}/action/unbind"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	id string
	body *ADDomainUpdateSpec
}

// Untrusted domain object to be updated.
func (r ApiUpdateRequest) Body(body ADDomainUpdateSpec) ApiUpdateRequest {
	r.body = &body
	return r
}

func (r ApiUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateExecute(r)
}

/*
Update Updates untrusted domain.

All the listed privileges are required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_MANAGEMENT | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id
 @return ApiUpdateRequest
*/
func (a *ExternalAPIService) Update(ctx context.Context, id string) ApiUpdateRequest {
	return ApiUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExternalAPIService) UpdateExecute(r ApiUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.Update")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains/{id}/action/update"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAuxiliaryAccountsRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	body *ADDomainAuxiliaryAccountUpdateSpec
}

// Specification to update auxiliary accounts.
func (r ApiUpdateAuxiliaryAccountsRequest) Body(body ADDomainAuxiliaryAccountUpdateSpec) ApiUpdateAuxiliaryAccountsRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAuxiliaryAccountsRequest) Execute() ([]BulkItemResponseInfo, *http.Response, error) {
	return r.ApiService.UpdateAuxiliaryAccountsExecute(r)
}

/*
UpdateAuxiliaryAccounts Update auxiliary accounts of the untrusted domain

All the listed privileges are required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_MANAGEMENT | Caller should have permission to this privilege, to perform this operation. |

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAuxiliaryAccountsRequest
*/
func (a *ExternalAPIService) UpdateAuxiliaryAccounts(ctx context.Context) ApiUpdateAuxiliaryAccountsRequest {
	return ApiUpdateAuxiliaryAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BulkItemResponseInfo
func (a *ExternalAPIService) UpdateAuxiliaryAccountsExecute(r ApiUpdateAuxiliaryAccountsRequest) ([]BulkItemResponseInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BulkItemResponseInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.UpdateAuxiliaryAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-domains/action/update-auxiliary-accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateADUserEncryptedCredentialsRequest struct {
	ctx context.Context
	ApiService *ExternalAPIService
	body *ADUserEncryptedCredentialSpec
}

// AD user encrypted credentials object to be validated.
func (r ApiValidateADUserEncryptedCredentialsRequest) Body(body ADUserEncryptedCredentialSpec) ApiValidateADUserEncryptedCredentialsRequest {
	r.body = &body
	return r
}

func (r ApiValidateADUserEncryptedCredentialsRequest) Execute() (*ADUserInfo, *http.Response, error) {
	return r.ApiService.ValidateADUserEncryptedCredentialsExecute(r)
}

/*
ValidateADUserEncryptedCredentials Validates the encrypted credentials of AD User

All the listed privileges are required -  
| Privileges | Description |
| ---- | ---- |
| GLOBAL_CONFIG_MANAGEMENT | Caller should have permission to this privilege to validate the encrypted credentials of AD User.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateADUserEncryptedCredentialsRequest
*/
func (a *ExternalAPIService) ValidateADUserEncryptedCredentials(ctx context.Context) ApiValidateADUserEncryptedCredentialsRequest {
	return ApiValidateADUserEncryptedCredentialsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ADUserInfo
func (a *ExternalAPIService) ValidateADUserEncryptedCredentialsExecute(r ApiValidateADUserEncryptedCredentialsRequest) (*ADUserInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ADUserInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExternalAPIService.ValidateADUserEncryptedCredentials")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/external/v1/ad-users-or-groups/action/validate-user-encrypted-credentials"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
